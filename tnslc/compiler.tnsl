# Actual compilation of the vector of tokens, ported from the "dirty tnsl"
# that was originally written for the interpreter

# CompData represents three vectors:
# hsec - the heading of the output assembly
# dsec - the data tied to the assembly
# csec - the .text section that is the code of the assembly
struct CompData {
    Vector
        hsec,
        dsec,
        csec
}

/; method CompData
    /; start
        self.hsec.start(1)
        self.dsec.start(1)
        self.csec.start(1)
    ;/

    /; add (CompData c)
        self.hsec.add(c.hsec)
        self.dsec.add(c.dsec)
        self.csec.add(c.csec)
    ;/

    /; _del
        self.hsec._del()
        self.dsec._del()
        self.csec._del()
    ;/
;/

# Path represents the actual path of a file
# that we are trying to tokenize
# Assumes that the last item in the path array is a file name
struct Path {
    int 
        path_count,
    ~~uint8
        split_path
}

/; method Path
    /; start (~uint8 path)
        self.split_path = _alloc(8)
        self.path_count = 0
        self.relative_file(path)
    ;/

    /; copy [Path]
        Path out
        ~uint8 f_pth = self.full_path()
        out.start(f_pth)
        _delete(f_pth)
        return out
    ;/
    
    /; relative_file(~uint8 rel_path)
        # Assume the last string is the file name
        /; if (self.path_count > 0)
            int idx = self.path_count - 1
            _delete(self.split_path{idx})
            self.path_count--
        ;/

        ~uint8 n_ptr = _alloc(1)
        n_ptr{0} = 0
        int idx = self.path_count

        /; loop (int i = 0; i < cstr_len(rel_path)) [i++]
            /; if (rel_path{i} == '\\' || rel_path{i} == '/')
                /; if (cstr_len(n_ptr) > 0)
                    self.path_count++
                    idx = self.path_count
                    self.split_path = _realloc(self.split_path, idx * 8)
                    self.split_path{idx - 1} = n_ptr

                    n_ptr = _alloc(1)
                    n_ptr{0} = 0
                ;/
            ;; else
                idx = cstr_len(n_ptr)
                n_ptr = _realloc(n_ptr, idx + 2)
                n_ptr{idx} = rel_path{i}
                n_ptr{idx + 1} = 0
            ;/
        ;/

        /; if (cstr_len(n_ptr) > 0)
            self.path_count++
            idx = self.path_count
            self.split_path = _realloc(self.split_path, idx * 8)
            self.split_path{idx - 1} = n_ptr
        ;/
    ;/

    /; full_path [~uint8]
        ~uint8 pth = _alloc(1)
        pth{0} = 0

        /; loop (int i = 0; i < self.path_count) [i++]
            ~uint8 w_ptr = self.split_path{i}
            
            int old_len = cstr_len(pth)
            int new_len = cstr_len(w_ptr) + old_len
            

            /; if (i < self.path_count - 1)
                pth = _realloc(pth, new_len + 2)
                pth{new_len} = '/'
                pth{new_len + 1} = 0
                old_len++
                new_len++
            ;; else
                pth = _realloc(pth, new_len + 1)
                pth{new_len} = 0
            ;/

            /; loop (int j = 0; j < new_len - old_len) [j++]
                pth{old_len + j} = w_ptr{j}
            ;/
        ;/

        return pth
    ;/

    /; open_read [~void]
        ~uint8 path = self.full_path()
        ~void out = _open_file(path)
        _delete(path)
        return out
    ;/

    /; open_write [~void]
        ~uint8 path = self.full_path()
        ~void out = _create_file(path)
        _delete(path)
        return out
    ;/

    /; _del
        /; loop (int i = 0; i < self.path_count) [i++]
            _delete(self.split_path{i})
        ;/

        _delete(self.split_path)
    ;/
;/

#
#
#

/; compile (Path in, out)

;/