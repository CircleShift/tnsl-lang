/; matching_delim (Vector v, int cur) [int]
	~Token cur
	cur = v.get(cur)


;/

# Entrypoint for round two
/; round_two (Path in, ~Module m) [CompData]
	CompData out
	out.start()	
	return out
;/


{}uint8 e_circular = "[TNSLC] [ERROR] Circular struct definition detected in structs:\n\0"
{}uint8 e_tc_nl = "\n\0"
{}uint8 e_noquit = "[TNSLC] [UB] PRE-ALPHA VERSION OF COMPILER UNABLE TO EXIT! UNDEFINED BEHAVIOUR AHEAD\n\0"
# Structure sizing for the first round
/; size_struct (~Type t, ~Module m)
	/; if (t`.s !== 0)
		return
	;/

	t`.s = 0 - 1
	int s = 0
	
	~Variable mb
	~Module mbm
	~Type mbt
	/; loop (int i = 0; i < t`.members.num_el) [i++]
		mb = t`.members.get(i)
		mbt = ~mb`.data_type
		/; if (mbt`.ptr_chain.num_el > 0)
			s = s + 8
		;; else if (mbt`.s > 0)
			s = s + mbt`.s
		;; else if (mbt`.s == 0)
			Vector v
			v.start(8)
			v.push(~mbt`.name)
			m`._find_type(v, 0)
			size_struct
		;; else if (mbt`.s < 0)
			_printf(~e_circular{0})

			_printf(t`.name)
			_printf(~e_tc_nl{0})

			_printf(mbt`.name)
			_printf(~e_tc_nl{0})
			
			_printf(~e_noquit{0})
		;/
	;/

	t`.s = s
;/

/; flush_structs (~Module m)
	~Type t
	/; loop(int i = 0; i < m`.typ.num_el) [i++]
		t = m`.typ.get(i)
		size_struct(t, m)
	;/
	
	~Module s
	/; loop(int i = 0; i < m`.sub.num_el) [i++]
		s = m`.sub.get(i)
		flush_structs(s)
	;/
;/

/; create_struct
;/

/; create_module (~uint8 name, bool e, bool m) [Module]
;/

{}uint8 r1_export = "export\0"
{}uint8 r1_module = "module\0"
{}uint8 r1_struct = "struct\0"
{}uint8 r1_method = "method\0"
/; round_one (Path in, ~Module root)	
	~uint8 pth = in.full_path()
	Vector v = tokenize_file(pth)
	_delete(pth)

	~Token cur
	/; loop (int i = 0; i < v.num_el) [i++]
		cur = v.get(i)
		/; if(cstr_eq(cur`.data, ~r1_struct{0}))
		;/
	;/

	flush_structs(root)
;/


/; compile (Path in, out)
	Module root
	root.start()
	root.exp = true

	round_one(in, ~root)
	CompData dat = round_two(in, ~root)
	
	~void fd = out.open_write()
	dat.write_file(fd)
	_close_file(fd)
;/

