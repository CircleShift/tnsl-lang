
uint16 NTYPE_MODULE = 0
uint16 NTYPE_EXPORT = 1
uint16 NTYPE_STRUCT = 2
uint16 NTYPE_TYPE = 3
uint16 NTYPE_ID = 4
uint16 NTYPE_BIN_OP = 5
uint16 NTYPE_PRE_OP = 6
uint16 NTYPE_POST_OP = 7
uint16 NTYPE_FUNCTION = 8
uint16 NTYPE_METHOD = 9
uint16 NTYPE_TLIST = 10
uint16 NTYPE_DLIST = 11
uint16 NTYPE_ELIST = 12
uint16 NTYPE_LITERAL = 13
uint16 NTYPE_KEY_TYPE = 14
uint16 NTYPE_ENUM = 15
uint16 NTYPE_DECL = 16
uint16 NTYPE_VLIST = 17
uint16 NTYPE_VALUE = 18
uint16 NTYPE_CAST = 19
uint16 NTYPE_FLOW_CONTROL = 20
uint16 NTYPE_CONTROL_BLOCK = 21
uint16 NTYPE_ASM = 998

struct Node {
	uint16 _type,
	~uint8 data,
	utils.Vector sub
}

/; method Node
	/; init (uint16 _type, ~uint8 data)
		self.data = data
		self._type = _type

		Node n
		self.sub.init(len n)
	;/

	/; eq (~uint8 cstr) [bool]
		/; if (utils.strcmp(self.data, cstr) == true)
			return true
		;/
		return false
	;/

	/; end
		_delete(self.data)
		
		/; loop (uint i = 0; i < self.sub.count) [i++]
			~Node cur = self.sub.get(i)
			cur`.end()
		;/
		self.sub.end()
	;/
;/

/; _get_closing_delim(uint8 ch) [uint8]
	/; if (ch == '/' || ch == ';')
		return ';'
	;; else if (ch == '(')
		return ')'
	;; else if (ch == '[')
		return ']'
	;; else if (ch == '{')
		return '}'
	;/
	return 0
;/

/; _is_closing(~Token tok) [bool]
	/; if (tok`._type !== TTYPE_DELIM)
		return false
	;/
	
	uint8 ch = tok`.data`
	/; if (ch == ';' || ch == '}' || ch == ']' || ch == ')')
		return true
	;/
	return false
;/

/; _advance_check(~utils.File fin, ~Token tok, ~uint8 eq) [bool]
	/; if (tok`._type !== TTYPE_ERR && tok`.eq(eq) == true)
		Token tmp = produce_next_token(fin, tok`)
		tok`.end()
		tok` = tmp
		return true
	;/
	return false
;/

/; _ast_print_err (~Token tok, ~uint8 msg)
	_printf(msg)
	_printf(":\n\0")
	_printf("  \0")
	print_token(tok`)
	_printf("\n\0")
;/

/; _ast_block_pass(~utils.File fin, ~Token first)
	/; loop (int deep = 1; deep > 0 && first`._type !== TTYPE_ERR)
		/; if (first`.eq(";/\0") == true)
			deep = deep - 1
		;; else if (first`.eq("/;\0") == true)
			deep = deep + 1
		;; else if (first`.eq(";;\0") == true && deep == 1)
			deep = deep - 1
		;/

		/; if (deep > 0)
			Token tmp = produce_next_token(fin, first`)
			first`.end()
			first` = tmp
		;/
	;/
;/



# AST values

/; _op_prefix(~Token op) [bool]
	int l = utils.strlen(op`.data)
	/; if (op`._type !== TTYPE_AUG)
		return false
	;/
	
	/; if (op`.eq("len\0") == true || op`.eq("--\0") == true || op`.eq("++\0") == true)
		return true
	;/

	/; if (l !== 1)
		return false
	;/

	/; if (op`.data` == '-' || op`.data` == '!' || op`.data` == '~')
		return true
	;/

	return false
;/

/; _op_postfix(~Token op) [bool]
	/; if (op`.eq("`\0") == true || op`.eq("++\0") == true || op`.eq("--\0") == true)
		return true
	;/
	return false
;/

/; _op_bin(~Token op) [bool]
	/; if (op`.eq("-\0") == true)
		return true
	;/
	/; if (_op_prefix(op) == true || _op_postfix(op) == true)
		return false
	;/
	return true
;/

/; _op_order(~uint8 op) [int]
	int l = utils.strlen(op)

	/; if (l == 1)
		uint8 ch = op`
		/; if (ch == '`')
			return 0
		;; else if (ch == '.')
			return 1
		;; else if (ch == '~')
			return 2
		;; else if (ch == '*' || ch == '/' || ch == '%')
			return 5
		;; else if (ch == '+' || ch == '-')
			return 6
		;; else if (ch == '!' || ch == '&' || ch == '|' || ch == '^')
			return 7
		;; else if (ch == '<' || ch == '>')
			return 8
		;; else if (ch == '=')
			return 10
		;/
	;; else if (l == 2)
		/; if (op{0} == op{1})
			uint8 ch = op`
			/; if (ch == '+' || ch == '-')
				return 3
			;; else if (ch == '<' || ch == '>')
				return 7
			;; else if (ch == '=')
				return 8
			;/
			return 9
		;/

		/; if (op{1} == '<' || op{1} == '>')
			return 8
		;; else if (op{1} == '=')
			return 10
		;; else if (op{0} == '!')
			return 7
		;/
	;; else if (l == 3)
		/; if (utils.strcmp(op, "len\0") == true)
			return 4
		;; else if (op{1} == '=')
			return 8
		;/
		return 9
	;/

	_printf("[FATAL] [CMPERR] _op_order: Augment not implemented in ordering \0")
	_print_num("'%s'\n\0", op)
	return 999
;/

/; _astv_pre_id (~utils.File fin, ~Node cur, ~Token first) [~Node]
	/; loop (first`._type == TTYPE_AUG)
		/; if (_op_prefix(first) == false)
			_ast_print_err(first, "Only certain augments (-, !, ~, --, ++, len) can be used as prefixes for bare values\0")
			return cur
		;/
		Node pre
		pre.init(NTYPE_PRE_OP, first`.data)

		cur`.sub.push(~pre)
		cur = cur`.sub.get(cur`.sub.count - 1)
		first` = produce_next_token(fin, first`)
	;/

	return cur
;/

/; _astv_cast (~utils.File fin, ~Node mod, ~Token first) [int]
	int out = first`.line
	/; if (first`.eq("[\0"))
		Node cast
		cast.init(NTYPE_CAST, utils.strcpy("\0"))
		out = _ast_list_type(fin, ~cast, first)
		~Node tmp = mod`.sub.get(mod`.sub.count - 1)
		cast.sub.push(tmp)
		mod`.sub.pop()
		mod`.sub.push(~cast)
	;/
	return out
;/

/; _astv_post_id (~utils.File fin, ~Node mod, ~Token first)
	int ln = first`.line
	/; loop (bool run = true; run == true && first`._type !== TTYPE_ERR)
		/; if (ln !== first`.line)
			run = false
		;; else if (_op_postfix(first) == true)
			Node post
			post.init(NTYPE_POST_OP, first`.data)
			mod`.sub.push(~post)
			first` = produce_next_token(fin, first`)
		;; else if (first`.eq("(\0") == true)
			ln = _ast_list_value(fin, mod, first)
		;; else if (first`.eq("{\0") == true)
			Node ind
			ind.init(NTYPE_POST_OP, first`.data)
			first` = produce_next_token(fin, first`)
			_ast_value(fin, ~ind, first)
			mod`.sub.push(~ind)
			/; if (_advance_check(fin, first, "}\0") == false)
				_ast_print_err(first, "Expected '}' to close index post op\0")
				run = false
			;/
		;; else
			run = false
		;/
	;/
;/

/; _ast_value_bare(~utils.File fin, ~Node mod, ~Token first) [bool]

	~Node cur = mod
	
	cur = _astv_pre_id(fin, cur, first)

	int ln = first`.line

	# Pre-flight check
	/; if (first`.eq("{\0") == true)
		ln = _ast_list_value(fin, cur, first)
	;; else if (_advance_check(fin, first, "(\0") == true)
		_ast_value(fin, cur, first)
		ln = first`.line
		/; if (_advance_check(fin, first, ")\0") == false)
			_ast_print_err(first, "Expected closing ')' for singlet\0")
			return false
		;/
		/; if (ln == first`.line)
			ln = _astv_cast(fin, cur, first)
			~Node tmp = cur`.sub.get(cur`.sub.count - 1)
		;/
	;; else if (first`._type == TTYPE_USRWD)
		Node val
		val.init(NTYPE_ID, first`.data)
		first` = produce_next_token(fin, first`)
		cur`.sub.push(~val)
	;; else if (first`._type == TTYPE_LITRL)
		Node val
		val.init(NTYPE_LITERAL, first`.data)
		first` = produce_next_token(fin, first`)
		cur`.sub.push(~val)
	;; else
		_ast_print_err(first, "Expected compound, parenthetical, literal, or identifier for bare value\0")
		return false
	;/
	
	/; if (ln == first`.line)
		ln = _astv_post_id(fin, cur`.sub.get(cur`.sub.count - 1), first)
	;; else
		return true
	;/

	bool run = ln == first`.line

	# Methods and members
	/; loop (bool run = true; run == true && _advance_check(fin, first, ".\0") == true)
		/; if (first`._type !== TTYPE_USRWD)
			_ast_print_err(first, "Expected method/member name after '.'\0")
			return false
		;/
		
		~Node repl = cur`.sub.get(cur`.sub.count - 1)
		Node dot
		dot.init(NTYPE_BIN_OP, utils.strcpy(".\0"))
		dot.sub.push(repl)

		Node val
		val.init(NTYPE_ID, first`.data)
		int ln = first`.line
		first` = produce_next_token(fin, first`)

		/; if (first`.line !== ln)
			run = false
		;; else
			_astv_post_id(fin, ~val, first)
		;/

		dot.sub.push(~val)

		cur`.sub.pop()
		cur`.sub.push(~dot)
		cur = cur`.sub.get(cur`.sub.count - 1)
	;/

	return true
;/

/; _ast_value (~utils.File fin, ~Node mod, ~Token first)
	
	Node val
	val.init(NTYPE_VALUE, utils.strcpy("\0"))

	~Node cur = ~val

	bool run = _ast_value_bare(fin, cur, first)
	
	/; loop (run == true && first`._type !== TTYPE_ERR)
		/; if (first`._type == TTYPE_SEP || _is_closing(first) == true)
			run = false
		;; else if (first`.eq(".\0") == true)
			run = false
		;; else if (first`._type == TTYPE_AUG && _op_bin(first) == true)
			Node bin
			bin.init(NTYPE_BIN_OP, first`.data)
			
			int i = _op_order(first`.data)
			bool gt = false
			/; if (cur`._type == NTYPE_BIN_OP)
				int j = _op_order(cur`.data)
				gt = i > j
			;/

			# Start from the top and work our way down
			/; if (gt == true)
				/; loop (cur = ~val; gt == true)
					~Node sub = cur`.sub.get(cur`.sub.count - 1)
					
					/; if (sub`._type == NTYPE_BIN_OP)
						int j = _op_order(sub`.data)
						gt = j !< i
					;/

					/; if (gt)
						cur = sub
					;/
				;/
			;/

			# Replace the last value in the current
			bin.sub.push(cur`.sub.get(cur`.sub.count - 1))
			cur`.sub.pop()
			cur`.sub.push(~bin)
			cur = cur`.sub.get(cur`.sub.count - 1)
			
			first` = produce_next_token(fin, first`)
			/; if (utils.strcmp(bin.data, "is\0"))
				_ast_type(fin, cur, first)
			;; else
				run = _ast_value_bare(fin, cur, first)
			;/

		;; else
			run = false
		;/
	;/

	mod`.sub.push(~val)
;/

/; _ast_keyword_expr (~utils.File fin, ~Node mod, ~Token first)
	int ln = first`.line

	/; if (first`.eq("return\0") == true || first`.eq("continue\0") == true || first`.eq("break\0") == true)
		Node ret
		ret.init(NTYPE_FLOW_CONTROL, first`.data)
		first` = produce_next_token(fin, first`)
		
		/; if (first`.line == ln && _is_closing(first) == false && first`._type !== TTYPE_ERR)
			_ast_value(fin, ~ret, first)
		;/
		mod`.sub.push(~ret)

		return
	;; else
		_ast_print_err(first, "Unsupported keyword statement\0")
		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
	;/
;/



# AST types

/; _type_helper_pre (~utils.File fin, ~Node mod, ~Token first)

	/; loop (bool run = true; first`._type !== TTYPE_ERR && run == true)
		/; if (first`._type == TTYPE_AUG && first`.eq("~\0") == true)
			# Pointer
			Node ptr
			ptr.init(NTYPE_PRE_OP, first`.data)
			mod`.sub.push(~ptr)
			first` = produce_next_token(fin, first`)
		;; else if (first`._type == TTYPE_DELIM && first`.eq("{\0") == true)
			# Array
			Node arr
			arr.init(NTYPE_PRE_OP, first`.data)
			first` = produce_next_token(fin, first`)
			
			/; if (first`._type == TTYPE_LITRL && is_numeric(first`.data`) == true)
				Node num
				num.init(NTYPE_LITERAL, first`.data)
				arr.sub.push(~num)

				first` = produce_next_token(fin, first`)

				/; if (first`.eq("}\0") == true)
					Token tmp = produce_next_token(fin, first`)
					first`.end()
					first` = tmp
				;; else
					_ast_print_err(first, "Expected closing '}' after integer in type declaration\0")
					run = false
				;/
			;; else if (first`.eq("}\0") == true)
				Token tmp = produce_next_token(fin, first`)
				first`.end()
				first` = tmp
			;; else
				_ast_print_err(first, "Expected integer or '}' to define either a fixed sized array or pointer to unknown sized array\0")
				run = false
			;/

			mod`.sub.push(~arr)

		;; else
			run = false
		;/
	;/

;/

/; _type_helper_func (~utils.File fin, ~Node mod, ~Token first)
	/; if (first`.eq("(\0") == true)
		_ast_list_type(fin, mod, first)
	;/

	/; if (first`.eq("[\0") == true)
		_ast_list_type(fin, mod, first)
	;/
;/

/; _type_helper_usertype (~utils.File fin, ~Node mod, ~Token first)
	
	/; loop (bool run = true; run == true && first`._type !== TTYPE_ERR)
		/; if (first`._type == TTYPE_USRWD)
			Node utp
			utp.init(NTYPE_ID, first`.data)
			first` = produce_next_token(fin, first`)
			mod`.sub.push(~utp)

			/; if (first`._type !== TTYPE_AUG || first`.eq(".\0") == false)
				run = false
			;; else
				Token tmp = produce_next_token(fin, first`)
				first`.end()
				first` = tmp
			;/
		;; else
			_ast_print_err(first, "Expected identifier in fully qualified type chain\0")
			run = false
		;/
	;/

	/; if (first`._type == TTYPE_DELIM && first`.eq("(\0") == true)
		_ast_list_type(fin, mod, first)
	;/
;/

/; _ast_type (~utils.File fin, ~Node mod, ~Token first)

	Node typ
	typ.init(NTYPE_TYPE, utils.strcpy("\0"))

	# Prefix values (~, {}, {#})
	_type_helper_pre(fin, ~typ, first)

	# Check to see if this is a function pointer type
	/; if (first`.eq("void\0") == true)
		Node ktp
		ktp.init(NTYPE_ID, first`.data)
		typ.sub.push(~ktp)
		first` = produce_next_token(fin, first`)
		
		_type_helper_func(fin, ~typ, first)
		mod`.sub.push(~typ)
		return
	;/

	# user type or keytype
	/; if (first`._type == TTYPE_USRWD)
		_type_helper_usertype(fin, ~typ, first)
	;; else if (first`._type == TTYPE_KEYTP)
		Node ktp
		ktp.init(NTYPE_ID, first`.data)
		typ.sub.push(~ktp)
		first` = produce_next_token(fin, first`)
	;; else
		_ast_print_err(first, "Expected keytype or usertype when parsing type\0")
		mod`.sub.push(~typ)
		return
	;/

	# The ol' reference
	/; if (first`.eq("`\0"))
		Node post
		post.init(NTYPE_POST_OP, first`.data)
		typ.sub.push(~post)
		first` = produce_next_token(fin, first`)
	;/

	mod`.sub.push(~typ)
;/



# AST lists

/; _ast_list_value (~utils.File fin, ~Node mod, ~Token first) [int]
	Node list
	list.init(NTYPE_VLIST, first`.data)

	uint8 end = _get_closing_delim(first`.data`)

	first` = produce_next_token(fin, first`)

	/; loop (first`._type !== TTYPE_ERR && first`.data` !== end)
		_ast_value(fin, ~list, first)

		/; if (_advance_check(fin, first, ",\0") == false && (first`._type !== TTYPE_DELIM || first`.data` !== end))
			_ast_print_err(first, "Expected ',' to continue the value list or a closing delimiter\0")
			mod`.sub.push(~list)
			return first`.line
		;/
	;/

	mod`.sub.push(~list)

	int ln = first`.line
	
	Token next = produce_next_token(fin, first`)
	first`.end()
	first` = next
	
	return ln
;/

/; _maybe_helper_decl (~utils.File fin, ~Node mod, ~Token first)
	# either a continuation of prev type or a new type then an id
	Token next = produce_next_token(fin, first`)
	/; if (next._type !== TTYPE_ERR && next.eq(",\0") || _is_closing(~next) == true)
		# Another id
		Node id
		id.init(NTYPE_ID, first`.data)
		mod`.sub.push(~id)

		first` = next
		return
	;/

	# have to parse as a type
	Node tp
	tp.init(NTYPE_TYPE, utils.strcpy("\0"))

	Node utmp
	utmp.init(NTYPE_ID, first`.data)

	tp.sub.push(~utmp)
	first` = next

	bool run = true
	/; if (first`._type !== TTYPE_AUG || first`.eq(".\0") == false)
		run = false
	;; else
		next = produce_next_token(fin, first`)
		first`.end()
		first` = next
	;/

	# Adapted from _type_helper_usertype
	/; loop (run == true && first`._type !== TTYPE_ERR)
		/; if (first`._type == TTYPE_USRWD)
			Node utp
			utp.init(NTYPE_ID, first`.data)
			first` = produce_next_token(fin, first`)
			tp.sub.push(~utp)

			/; if (first`._type !== TTYPE_AUG || first`.eq(".\0") == false)
				run = false
			;; else
				next = produce_next_token(fin, first`)
				first`.end()
				first` = next
			;/
		;; else
			_ast_print_err(first, "Expected identifier in fully qualified type chain\0")
			run = false
		;/
	;/

	/; if (first`._type == TTYPE_DELIM && first`.eq("(\0") == true)
		_ast_list_type(fin, ~tp, first)
	;/

	mod`.sub.push(~tp)

	/; if (first`._type !== TTYPE_USRWD)
		_ast_print_err(first, "Expected identifier after user type in type list\0")
		return
	;/

	Node id
	id.init(NTYPE_ID, first`.data)
	mod`.sub.push(~id)

	first` = produce_next_token(fin, first`)
;/

/; _ast_list_decl (~utils.File fin, ~Node mod, ~Token first) [int]
	Node list
	list.init(NTYPE_DLIST, first`.data)

	uint8 end = _get_closing_delim(first`.data`)

	first` = produce_next_token(fin, first`)
	bool seen = false

	/; loop (first`._type !== TTYPE_ERR && first`.data` !== end)
		/; if (seen == false || first`._type == TTYPE_KEYTP || first`.eq("~\0") == true || first`.eq("{\0") == true)
			_ast_type(fin, ~list, first)

			/; if (first`._type !== TTYPE_USRWD)
				/; if (seen == false)
					_ast_print_err(first, "Expected type then identifier as first items in declaration list\0")
				;; else
					_ast_print_err(first, "Expected identifier after type in params/struct def\0")
				;/
				mod`.sub.push(~list)
				return first`.line
			;/

			seen = true

			Node id
			id.init(NTYPE_ID, first`.data)

			list.sub.push(~id)
			first` = produce_next_token(fin, first`)

		;; else if (first`._type == TTYPE_USRWD)
			_maybe_helper_decl(fin, ~list, first)
		;; else
			_ast_print_err(first, "Expected type or parameter name in declaration list\0")
			mod`.sub.push(~list)
			return first`.line
		;/

		/; if (_advance_check(fin, first, ",\0") == false && _is_closing(first) == false)
			_ast_print_err(first, "Expected ',' to continue the declaration list or a closing delimiter\0")
			mod`.sub.push(~list)
			return first`.line
		;/
	;/

	mod`.sub.push(~list)
	
	int ln = first`.line

	Token next = produce_next_token(fin, first`)
	first`.end()
	first` = next

	return ln
;/

/; _ast_list_enum (~utils.File fin, ~Node mod, ~Token first) [int]
	Node list
	list.init(NTYPE_ELIST, first`.data)

	uint8 end = _get_closing_delim(first`.data`)

	first` = produce_next_token(fin, first`)

	int ln = first`.line

	/; loop (first`._type !== TTYPE_ERR && first`.data` !== end)
		/; if (first`._type == TTYPE_USRWD)
			ln = first`.line

			Node enum_id
			enum_id.init(NTYPE_ID, first`.data)
			
			first` = produce_next_token(fin, first`)

			/; if (_advance_check(fin, first, "=\0"))
				_ast_value(fin, ~enum_id, first)
			;/

			list.sub.push(~enum_id)
			
		;; else
			_ast_print_err(first, "Expected identifier in body of enum declaration\0")
			mod`.sub.push(~list)
			return ln
		;/
		
		/; if (first`.eq(",\0") == true)
			ln = first`.line
		;/

		/; if (_advance_check(fin, first, ",\0") == false && _is_closing(first) == false)
			_ast_print_err(first, "Expected ',' to continue the type list or a closing delimiter\0")
			mod`.sub.push(~list)
			return ln
		;/
	;/

	mod`.sub.push(~list)

	ln = first`.line
	
	Token next = produce_next_token(fin, first`)
	first`.end()
	first` = next

	return ln
;/

/; _ast_list_type (~utils.File fin, ~Node mod, ~Token first) [int]
	Node list
	list.init(NTYPE_TLIST, first`.data)

	uint8 end = _get_closing_delim(first`.data`)

	first` = produce_next_token(fin, first`)

	int ln = first`.line

	/; loop (first`._type !== TTYPE_ERR && first`.data` !== end)

		/; if (first`._type == TTYPE_USRWD || first`._type == TTYPE_KEYTP || first`.eq("~\0") == true || first`.eq("{\0") == true)
			ln = first`.line
			_ast_type(fin, ~list, first)
		;; else
			_ast_print_err(first, "Expected type in type list\0")
			mod`.sub.push(~list)
			return ln
		;/

		/; if (_advance_check(fin, first, ",\0") == false && _is_closing(first) == false)
			_ast_print_err(first, "Expected ',' to continue the type list or a closing delimiter\0")
			mod`.sub.push(~list)
			return ln
		;/
	;/

	mod`.sub.push(~list)

	ln = first`.line

	Token next = produce_next_token(fin, first`)
	first`.end()
	first` = next

	return ln
;/



# Method blocks

/; _block_helper_method(~utils.File fin, ~Node mod, ~Token first)
	Token blf = first`

	first` = produce_next_token(fin, first`)

	/; loop (bool run = true; run == true)
		/; if (first`._type == TTYPE_USRWD)
			_ast_function(fin, mod, first)
		;; else
			_ast_print_err(first, "Expected function or operator overload in method block\0")
		;/

		_ast_block_pass(fin, first)

		/; if (_advance_check(fin, first, ";/\0") == true)
			/; if (first`.data` == ';')
				run = false
			;; else if (_advance_check(fin, first, "/;\0") == false)
				_ast_print_err(first, "Expected opening block in method block\0")
			;/
		;; else if (_advance_check(fin, first, ";;\0") == false)
			_ast_print_err(~blf, "Could not find closing ;/ for function in method block\0")
			run = false
		;/
	;/

	blf.end()
;/

/; _ast_method (~utils.File fin, ~Node mod, ~Token first)
	Token blf = first`

	/; if (first`._type !== TTYPE_USRWD)
		_ast_print_err(first, "Expected identifier of struct after 'method'\0")
		return
	;/

	Node mth
	mth.init(NTYPE_METHOD, first`.data)
	first` = produce_next_token(fin, first`)

	/; loop (bool run = true; run == true && first`._type == TTYPE_DELIM)
		/; if (first`.eq("/;\0") == true)
			_block_helper_method(fin, ~mth, first)
		;; else
			/; if (first`.data` !== ';')
				_ast_print_err(first, "Method block being skipped. Parsing will resume after the end\0")
			;/
			run = false
		;/
	;/

	_ast_block_pass(fin, first)

	/; if (first`.eq(";/\0") == false)
		_ast_print_err(~blf, "Could not find closing ;/ for method block\0")
	;/

	mod`.sub.push(~mth)
;/



# function blocks

/; _ast_if (~utils.File fin, ~Node mod, ~Token first)
;/

/; _ast_loop (~utils.File fin, ~Node mod, ~Token first)
;/

/; _ast_fun_block (~utils.File fin, ~Node mod, ~Token first)
	Token blf = first`
	first` = produce_next_token(fin, first`)

	/; loop (bool run = true; run == true && first`._type !== TTYPE_ERR)
		/; if (_advance_check(fin, first, "if\0") == true)
			_ast_if(fin, mod, first)
		;; else if (_advance_check(fin, first, "loop\0") == true)
			_ast_loop(fin, mod, first)
		# ;; else if (first`._type == TTYPE_USRWD)
		#	_ast_function(fin, mod, first)
		;; else
			_ast_print_err(first, "Expected 'if' or 'loop' for function level block\0")
		;/

		run = _advance_check(fin, first, ";;\0")
		/; if (run == false && first`.eq(";/\0") == false)
			_ast_print_err(first, "Block being skipped. Parsing will pick up after the end\0")
		;/
	;/

	_ast_block_pass(fin, first)

	/; if (_advance_check(fin, first`, ";/\0") == false)
		_ast_print_err(~blf, "Could not find closing ;/ for top block\0")
	;/
	blf.end()
;/

/; _mhf_post (~utils.File fin, ~Node mod, ~Token first) [bool]
	return false
;/

# Transform type nodes into value nodes
/; _mhf_transform (~Node _type)
	Node out
	out.init(NTYPE_VALUE, utils.strcpy("\0"))
	
	~Node sub, cur
	cur = ~out
	int idx = 0
	
	/; loop (bool run = true; run == true && idx < _type`.sub.count)
		sub = _type`.sub.get(idx)
		/; if (sub`._type !== NTYPE_PRE_OP)
			run = false
		;; else
			Node new
			new.init(NTYPE_PRE_OP, utils.strcpy(sub`.data))
			cur`.sub.push(~new)
			int last = cur`.sub.count - 1
			cur = cur`.sub.get(last)
			idx++
		;/
	;/

	/; loop (idx < _type`.sub.count && sub`._type == NTYPE_ID)
		/; if (idx < _type`.sub.count - 1)
			sub = _type`.sub.get(idx + 1)
			/; if (sub`._type == NTYPE_ID)
				Node op, n
				op.init(NTYPE_BIN_OP, utils.strcpy(".\0"))
				n.init(NTYPE_ID, utils.strcpy(sub`.data))
				op.sub.push(~n)
				cur`.sub.push(~op)
				int last = cur`.sub.count - 1
				cur = cur`.sub.get(last)
			;; else
				Node n
				n.init(NTYPE_ID, utils.strcpy(sub`.data))
				cur`.sub.push(~n)
				int last = cur`.sub.count - 1
				cur = cur`.sub.get(last)
			;/
		;; else
			Node n
			n.init(NTYPE_ID, utils.strcpy(sub`.data))
			cur`.sub.push(~n)
			int last = cur`.sub.count - 1
			cur = cur`.sub.get(last)
		;/

		idx++

		/; if (idx < _type`.sub.count)
			sub = _type`.sub.get(idx)
		;/
	;/
	
	/; if (sub`._type == NTYPE_TLIST && sub`.eq("(\0") == true)
		Node lst
		lst.init(NTYPE_VLIST, "(\0")
		
		/; loop (int i = 0; i < sub`.sub.count) [i++]
			~Node lsub = sub`.sub.get(i)
			_mhf_transform(lsub)
			lst.sub.push(lsub)
		;/
		
		/; loop (sub`.sub.count > 0)
			sub`.sub.pop()
		;/

		cur`.sub.push(~lst)
	;/

	_type`.end()
	_type` = out
;/

/; _mhf_finish_value (~utils.File fin, ~Node mod, ~Token first)
;/

/; _mhf_finish_decl (~utils.File fin, ~Node mod, ~Token first)
;/

/; _maybe_helper_fun (~utils.File fin, ~Node mod, ~Token first)
	# Try parsing as a type first, and if we encounter something weird we will transform
	# the output into a value before proceeding
	Node out
	out.init(NTYPE_TYPE, utils.strcpy("\0"))

	_type_helper_pre(fin, ~out, first)

	/; if (first`.eq("(\0"))
		_mhf_transform(~out)
		_mhf_finish_value(fin, ~out, first)
		
	;; else if (first`._type == TTYPE_KEYTP)
		_mhf_finish_decl(fin, ~out, first)

	;; else if (first`._type !== TTYPE_USRWD)
		_ast_print_err(first, "Unexpected token. Expected the completion of a declaration or value\0")

	;; else if (_mhf_post(fin, ~out, first))
		_mhf_finish_decl(fin, ~out, first)

	;; else
		_mhf_transform(~out)
		_mhf_finish_value(fin, ~out, first)
	;/

	mod`.sub.push(~out)
;/

/; _ast_function (~utils.File fin, ~Node mod, ~Token first)
	/; if (first`._type !== TTYPE_USRWD)
		_ast_print_err(first, "[FATAL] [CMPERR] Expected function name\0")
		return
	;/

	Node fn
	fn.init(NTYPE_FUNCTION, first`.data)
	first` = produce_next_token(fin, first`)

	/; if (first`.eq("(\0") == true)
		_ast_list_decl(fin, ~fn, first)
	;/

	/; if (first`.eq("[\0") == true)
		_ast_list_type(fin, ~fn, first)
	;/
	
	/; loop (bool run = true; run == true && first`._type !== TTYPE_ERR)
		/; if (_advance_check(fin, first, "asm\0") == true)
			_ast_asm(fin, ~fn, first)
		;; else if (first`.eq("/;\0") == true)
			_ast_fun_block(fin, ~fn, first)
		;; else if (first`._type == TTYPE_KEYTP || first`.eq("{\0") == true)
			_ast_decl(fin, ~fn, first)
		;; else if (first`._type == TTYPE_USRWD || first`.eq("~\0") == true)
			_maybe_helper_fun(fin, ~fn, first)
		;; else if (first`._type == TTYPE_KEYWD)
			_ast_keyword_expr(fin, ~fn, first)
		;; else if (first`._type == TTYPE_DELIM && first`.data` == ';')
			run = false
		;; else
			_ast_print_err(first, "Expected definition, expression, or sub block in function\0")

			Token tmp = produce_next_token(fin, first`)
			first`.end()
			first` = tmp
		;/
	;/

	mod`.sub.push(~fn)
;/



# Top level directives

/; _ast_import (~utils.File fin, ~Node mod, ~Token first)

	/; if (first`._type !== TTYPE_LITRL || first`.data` !== '"')
		_ast_print_err(first, "Expected string or import literal after 'import'\0")

		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
		
		return
	;/

	~uint8 rel = utils.unquote_str(first`.data)
	utils.File imp = fin`.relative(rel)
	_delete(rel)

	rel = imp.path.to_cstr('/')
	_printf("Importing \0")
	_printf(rel)
	_printf("\n\0")
	_delete(rel)

	_ast_file(~imp, mod)
	imp.end()

	Token tmp = produce_next_token(fin, first`)
	first`.end()
	first` = tmp
;/

/; _ast_asm (~utils.File fin, ~Node mod, ~Token first)

	/; if (first`._type !== TTYPE_LITRL || first`.data` !== '"')
		_ast_print_err(first, "Expected string literal after 'ast'\0")

		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
		
		return
	;/
	
	Node an
	an.init(NTYPE_ASM, utils.unquote_str(first`.data))
	mod`.sub.push(~an)

	Token tmp = produce_next_token(fin, first`)
	first`.end()
	first` = tmp
;/

/; _ast_struct (~utils.File fin, ~Node mod, ~Token first)
	
	# Identifier check
	/; if (first`._type !== TTYPE_USRWD)
		_ast_print_err(first, "Expected new identifier for typedef after 'struct'\0")

		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
		
		return
	;/

	# Root struct node
	Node sct
	sct.init(NTYPE_STRUCT, first`.data)
	first` = produce_next_token(fin, first`)

	# Check for def list
	/; if (first`._type !== TTYPE_DELIM || first`.data` !== '{')
		_ast_print_err(first, "Expected new identifier for typedef after 'struct'\0")
		mod`.sub.push(~sct)

		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
		
		return
	;/

	# Parse deflist and push root node into module
	_ast_list_decl(fin, ~sct, first)
	mod`.sub.push(~sct)
;/

/; _ast_enum (~utils.File fin, ~Node mod, ~Token first)
	# Identifier check
	/; if (first`._type !== TTYPE_USRWD)
		_ast_print_err(first, "Expected new identifier for def after 'enum'\0")

		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
		
		return
	;/

	# Root struct node
	Node sct
	sct.init(NTYPE_ENUM, first`.data)
	first` = produce_next_token(fin, first`)

	# Check for enum type
	/; if (first`.data` == '[')
		_ast_list_type(fin, ~sct, first)

		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
	;/

	# Check for def list
	/; if (first`._type !== TTYPE_DELIM || first`.data` !== '{')
		_ast_print_err(first, "Expected new identifier for typedef after 'struct'\0")
		mod`.sub.push(~sct)

		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
		
		return
	;/

	# Parse deflist and push root node into module
	_ast_list_enum(fin, ~sct, first)
	mod`.sub.push(~sct)
	
	Token tmp = produce_next_token(fin, first`)
	first`.end()
	first` = tmp
;/

/; _ast_decl (~utils.File fin, ~Node mod, ~Token first)
	Node decl
	decl.init(NTYPE_DECL, utils.strcpy("\0"))
	
	_ast_type(fin, ~decl, first)

	/; loop (bool run = true; run == true)
		/; if (first`._type == TTYPE_USRWD)
			Node var
			var.init(NTYPE_ID, first`.data)

			first` = produce_next_token(fin, first`)
			/; if (first`.eq("=\0"))
				Token tmp = produce_next_token(fin, first`)
				first`.end()
				first` = tmp
				_ast_value(fin, ~var, first)
			;/

			decl.sub.push(~var)

			/; if (first`.eq(",\0") == false)
				run = false
			;; else
				Token tmp = produce_next_token(fin, first`)
				first`.end()
				first` = tmp
			;/
		;; else
			_ast_print_err(first, "Expected variable name in declaration\0")
			run = false
		;/
	;/

	mod`.sub.push(~decl)
;/

/; _ast_top_block(~utils.File fin, ~Node mod, ~Token first)

	Token blf = first`
	first` = produce_next_token(fin, first`)

	/; loop (bool run = true; run == true && first`._type !== TTYPE_ERR)
		/; if (first`.eq("module\0") == true || first`.eq("export\0") == true)
			_ast_module(fin, mod, first)
		;; else if (_advance_check(fin, first, "method\0") == true)
			_ast_method(fin, mod, first)
		;; else if (first`._type == TTYPE_USRWD)
			_ast_function(fin, mod, first)
		;; else
			_ast_print_err(first, "Expected module, method, or function for top level block\0")
		;/

		run = _advance_check(fin, first, ";;\0")
		/; if (run == false && first`.eq(";/\0") == false && first`.eq(";;\0") == false)
			_ast_print_err(first, "Block being skipped. Parsing will pick up after the end\0")
		;/
	;/

	_ast_block_pass(fin, first)

	/; if (first`.eq(";/\0") == false && first`.eq(";;\0") == false)
		_ast_print_err(~blf, "Could not find closing ;/ for top block\0")
	;; else
		Token tmp = produce_next_token(fin, first`)
		first`.end()
		first` = tmp
	;/
	blf.end()
;/

/; _ast_module(~utils.File fin, ~Node mod, ~Token first)
	uint16 nt = NTYPE_MODULE

	/; if (_advance_check(fin, first, "export\0") == true)
		/; if (_advance_check(fin, first, "module\0") == false)
			_ast_print_err(first, "Expected 'module' keyword after 'export'\0")
			return
		;/
		nt = NTYPE_EXPORT
	;; else if (_advance_check(fin, first, "module\0") == false)
		_printf("[FATAL] The following issue is with the compiler, not your program.\n\0")
		_printf("[FATAL] Please report the following issue to tnslc upstream.\n\0")
		_ast_print_err(first, "[FATAL] [CMPERR] Should only call _ast_module when 'module' or 'export' are seen\0")
	;/

	/; if (first`._type !== TTYPE_USRWD)
		_ast_print_err(first, "Expected module name (identifier) after 'module'\0")
	;/

	Node nmod
	nmod.init(nt, first`.data)
	first` = produce_next_token(fin, first`)

	/; loop (bool run = true; run == true && first`._type !== TTYPE_ERR)
		/; if (_advance_check(fin, first, "import\0") == true)
			_ast_import(fin, ~nmod, first)
		;; else if (_advance_check(fin, first, "struct\0") == true)
			_ast_struct(fin, ~nmod, first)
		;; else if (_advance_check(fin, first, "enum\0") == true)
			_ast_enum(fin, ~nmod, first)
		;; else if (_advance_check(fin, first, "asm\0") == true)
			_ast_asm(fin, ~nmod, first)
		;; else if (first`.eq("/;\0") == true)
			_ast_top_block(fin, ~nmod, first)
		;; else if (first`._type == TTYPE_KEYTP || first`._type == TTYPE_USRWD || first`.eq("~\0") == true || first`.eq("{\0") == true)
			_ast_decl(fin, ~nmod, first)
		;; else if (first`._type == TTYPE_DELIM && first`.data` == ';')
			run = false
		;; else
			_ast_print_err(first, "Expected 'import', 'struct', 'asm', block, or declaration in top level\0")

			Token tmp = produce_next_token(fin, first`)
			first`.end()
			first` = tmp
		;/
	;/

	mod`.sub.push(~nmod)
;/

/; _ast_file (~utils.File fin, ~Node mod)
	fin`.open()
	
	Token first = produce_first_token(fin)
	/; loop (first._type !== TTYPE_ERR)
		/; if (_advance_check(fin, ~first, "import\0") == true)
			_ast_import(fin, mod, ~first)
		;; else if (_advance_check(fin, ~first, "struct\0") == true)
			_ast_struct(fin, mod, ~first)
		;; else if (_advance_check(fin, ~first, "enum\0") == true)
			_ast_enum(fin, mod, ~first)
		;; else if (_advance_check(fin, ~first, "asm\0") == true)
			_ast_asm(fin, mod, ~first)
		;; else if (first.eq("/;\0") == true)
			_ast_top_block(fin, mod, ~first)
		;; else if (first._type == TTYPE_KEYTP || first._type == TTYPE_USRWD || first.eq("~\0") == true || first.eq("{\0") == true)
			_ast_decl(fin, mod, ~first)
		;; else
			_ast_print_err(~first, "Expected 'import', 'struct', 'asm', block, or declaration in top level\0")

			Token tmp = produce_next_token(fin, first)
			first.end()
			first = tmp
		;/
	;/

	first.end()

	fin`.close()
;/

/; generate_ast (~utils.File fin) [Node]
	Node out

	utils.Vector v
	v.init(1)

	out.init(NTYPE_MODULE, v.as_cstr())

	_ast_file(fin, ~out)

	return out
;/

#
# Print out the AST from a specific node
#

/; print_node_type (~Node n)
	/; if (n`._type == NTYPE_MODULE)
		_printf("MODULE\0")
	;; else if (n`._type == NTYPE_EXPORT)
		_printf("EXPORT\0")
	;; else if (n`._type == NTYPE_STRUCT)
		_printf("STRUCT\0")
	;; else if (n`._type == NTYPE_TYPE)
		_printf("TYPE\0")
	;; else if (n`._type == NTYPE_ID)
		_printf("ID\0")
	;; else if (n`._type == NTYPE_BIN_OP)
		_printf("BIN_OP\0")
	;; else if (n`._type == NTYPE_PRE_OP)
		_printf("PRE_OP\0")
	;; else if (n`._type == NTYPE_POST_OP)
		_printf("POST_OP\0")
	;; else if (n`._type == NTYPE_FUNCTION)
		_printf("FUNCTION\0")
	;; else if (n`._type == NTYPE_METHOD)
		_printf("METHOD\0")
	;; else if (n`._type == NTYPE_TLIST)
		_printf("TLIST\0")
	;; else if (n`._type == NTYPE_DLIST)
		_printf("DLIST\0")
	;; else if (n`._type == NTYPE_ELIST)
		_printf("ELIST\0")
	;; else if (n`._type == NTYPE_LITERAL)
		_printf("LITERAL\0")
	;; else if (n`._type == NTYPE_KEY_TYPE)
		_printf("KEY_TYPE\0")
	;; else if (n`._type == NTYPE_ENUM)
		_printf("ENUM\0")
	;; else if (n`._type == NTYPE_DECL)
		_printf("DECL\0")
	;; else if (n`._type == NTYPE_VLIST)
		_printf("VLIST\0")
	;; else if (n`._type == NTYPE_VALUE)
		_printf("VALUE\0")
	;; else if (n`._type == NTYPE_CAST)
		_printf("CAST\0")
	;; else if (n`._type == NTYPE_FLOW_CONTROL)
		_printf("FLOW_CONTROL\0")
	;; else if (n`._type == NTYPE_CONTROL_BLOCK)
		_printf("CONTROL_BLOCK\0")
	;; else if (n`._type == NTYPE_ASM)
		_printf("ASM\0")
	;/
;/

/; print_node_head (~Node n)
	_printf("{ NODE_TYPE: \0")
	print_node_type(n)
	_printf(", DATA: \0")
	_printf(n`.data)
	_printf("\n\0")
;/

/; print_ast_rec(~Node n, uint depth)
	/; loop (int i = 0; i < depth) [i++]
		_printf("  \0")
	;/
	print_node_head(n)

	/; loop (uint i = 0; i < n`.sub.count) [i++]
		~Node s = n`.sub.get(i)
		print_ast_rec(s, depth + 1)
	;/
	
	/; loop (int i = 0; i < depth) [i++]
		_printf("  \0")
	;/
	_printf("}\n\0")
;/

/; print_ast (~Node n)
	print_ast_rec(n, 0)
;/


