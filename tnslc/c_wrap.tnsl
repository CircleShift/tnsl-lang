/; _alloc (uint size) [~void]
    ~void out
    # Mov size into proper register, and set all extras to zero
    asm "mov rdi, rax"
    asm "mov rsi, 0"
    asm "mov rdx, 0"
    asm "mov rcx, 0"
    asm "mov r8, 0"
    asm "mov r9, 0"
    asm "mov r10, 0"
    asm "call malloc"
    # Set out to the returned value
    # (The compiler assignes spaces sequentially, and we have a uint in r8)
    asm "mov r9, rax"
    return out
;/

/; _realloc (~void ptr, uint new_size) [~void]
    ~void out
    # Mov ptr and new size into proper registers, and set all extras to zero
    asm "mov rdi, rax"
    asm "mov rsi, rbx"
    asm "mov rdx, 0"
    asm "mov rcx, 0"
    asm "mov r8, 0"
    asm "mov r9, 0"
    asm "mov r10, 0"
    # Do call
    asm "call realloc"
    # Set out to the returned value
    # (The compiler assignes spaces sequentially. We have a ptr in r8, and a uint in r9)
    asm "mov r10, rax"
    return out
;/

/; _delete (~void ptr)
    # setup call
    asm "mov rdi, rax"
    asm "mov rsi, 0"
    asm "mov rdx, 0"
    asm "mov rcx, 0"
    asm "mov r8, 0"
    asm "mov r9, 0"
    asm "mov r10, 0"
    # do call
    asm "call free"
    # there's no more to do 'cause free returns nothing 
;/

struct Array {
    int el_size,
    int num_el,
    ~void dat
}

/; method Array

    /; resize (int num_el)
        _realloc(dat, num_el * self.el_size)
    ;/

    /; get (int i) [~void]
        /; if (i > self.num_el)
            return self.dat
        ;/
        return self.dat + (i * self.el_size)
    ;/

    /; set (int i, ~void data)

    ;/
;/