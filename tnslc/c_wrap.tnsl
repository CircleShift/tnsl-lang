asm "extern malloc"
asm "extern realloc"
asm "extern free"

/; _alloc (uint size) [~void]
    ~void out
    # Mov size into proper register, and set all extras to zero
    asm "mov rdi, rax"
    asm "mov rsi, 0"
    asm "mov rdx, 0"
    asm "mov rcx, 0"
    asm "mov r8, 0"
    asm "mov r9, 0"
    asm "mov r10, 0"
    asm "call malloc"
    # Set out to the returned value
    # (The compiler assignes spaces sequentially, and we have a uint in r8)
    asm "mov r9, rax"
    return out
;/

/; _realloc (~void ptr, uint new_size) [~void]
    ~void out
    # Mov ptr and new size into proper registers, and set all extras to zero
    asm "mov rdi, rax"
    asm "mov rsi, rbx"
    asm "mov rdx, 0"
    asm "mov rcx, 0"
    asm "mov r8, 0"
    asm "mov r9, 0"
    asm "mov r10, 0"
    # Do call
    asm "call realloc"
    # Set out to the returned value
    # (The compiler assignes spaces sequentially. We have a ptr in r8, and a uint in r9)
    asm "mov r10, rax"
    return out
;/

/; _delete (~void ptr)
    # setup call by clearing most values
    asm "mov rdi, rax"
    asm "mov rsi, 0"
    asm "mov rdx, 0"
    asm "mov rcx, 0"
    asm "mov r8, 0"
    asm "mov r9, 0"
    asm "mov r10, 0"
    # do call
    asm "call free"
    # there's no more to do 'cause free returns nothing 
;/

struct Vector {
    uint
        el_size,
        num_el,
        dat_size,
    ~void dat
}

/; method Vector

    /; resize (uint num_el)
        self.dat_size = num_el
        _realloc(self.dat, num_el * self.el_size)
    ;/

    /; get (uint i) [~void]
        /; if (i !< self.num_el)
            return self.dat
        ;/
        return self.dat + (i * self.el_size)
    ;/

    /; set (uint i, ~void data)
        ~void index = get(i)
        /; loop (i = 0; i < self.el_size) [index = index + 1; data = data + 1; i++]
            index = data
        ;/
    ;/

    /; push (~void data)
        self.num_el++
        self.set(self.num_el - 1, data)
        /; if (self.num_el !< self.dat_size)
            self.resize(2*self.dat_size)
        ;/
    ;/

    /; pop
        self.num_el--
        /; if (self.num_el !== 0 && self.num_el < self.dat_size / 4)
            self.resize(self.dat_size / 2)
        ;/
    ;/

    /; remove (int index)
        index++
        /; loop (index < self.num_el) [index++]
            self.set(index - 1, self.get(index))
        ;/
        self.pop()
    ;/

    /; start (int el_size)
        self.num_el = 0
        self.el_size = el_size
        self.dat_size = 1
        self.dat = _alloc(self.el_size)
    ;/

    /; clean
        self.num_el = 0
        self.el_size = 0
        self.dat_size = 0
        _delete(self.dat)
        self.dat = 0
    ;/
;/
