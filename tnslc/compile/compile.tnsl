/##
	Copyright 2021-2022 Kyle Gunger

	This file is licensed under the CDDL 1.0 (the License)
	and may only be used in accordance with the License.
	You should have received a copy of the License with this
	software/source code. If you did not, a copy can be found
	at the following URL:

	https://opensource.org/licenses/CDDL-1.0

	THIS SOFTWARE/SOURCE CODE IS PROVIDED "AS IS" WITH NO
	WARRANTY, GUARANTEE, OR CLAIM OF FITNESS FOR ANY PURPOSE
	EXPRESS OR IMPLIED
#/


;{}{}charp COMMON_ASM = {
	"\tret\n"
}

# Represents a type
;struct VType {
	uint
		_size,
	int
		ptr,
	
	{}charp name
}

# Tracks defined variables in a block
;struct VTrack {
	{}{}charp
		sym_names,
	
	{}VType
		sym_types
}

# Sizes of items
;{}VType type_table = {
	{1, 0, "int8"},
	{2, 0, "int16"},
	{4, 0, "int32"},
	{8, 0, "int64"},
	{8, 0, "int"},
	{1, 0, "uint8"},
	{2, 0, "uint16"},
	{4, 0, "uint32"},
	{8, 0, "uint64"},
	{8, 0, "uint"},
	{4, 0, "float32"},
	{8, 0, "float64"},
	{8, 0, "float"},
	{1, 0, "bool"},
	{8, 0, "void"}
}

# Null type
;VType NT = {0, 0, "null"}

# Returns an index in the vtrack for a given variable name
/; name_to_index ({}charp name, ~VTrack tab) [int]
	/; loop (int i = 0; i < len (tab`.sym_names)) [i++]
		/; if (string_equate(tab`.sym_names{i}, name))
			;return i
		;/
	;/

	;tnsl.io.print("Failed to find vairable ")
	;tnsl.io.println(name)

	;return -1
;/

/; reg_by_num(int r) [{}charp]
	/; if (r == 0)
		;return "ax"
	;; if (r == 1)
		;return "bx"
	;; if (r == 2)
		;return "cx"
	;; if (r == 3)
		;return "dx"
	;; if (r == 4)
		;return "si"
	;; if (r == 5)
		;return "di"
	;; if (r == 6)
		;return "bp"
	;; if (r == 7)
	;/
	;return string_from_int(r)
;/

# Given an index in the vtrack, returns a string representation of the
# register or memory where that variable is
/; index_to_loc (int index, ~VTrack tab) [{}charp]
	;{}charp out = ""
	;int stack_bytes = 0
	;int reg = 0
	;int i = 0

	/; loop (i < index) [i++]
		/; if (tab`.sym_types{i}._size !> 8 && reg < 7)
			;reg++
		;; else
			;stack_bytes = stack_bytes + tab`.sym_types{i}._size
		;/
	;/

	/; if (is_struct(tab`.sym_types{index}))
		;out = "(todo: structs)"
	;; else
		;out = reg_by_num(reg)
	;/
	
	;return out
;/

# Is struct returns true if the type name given is a struct
/; is_struct (VType t) [bool]
	/; if (t.ptr > 0)
		;return false
	;/

	/; loop (int i = 0; i < 15) [i++]
		/; if (string_equate(type_table{i}.name, t.name))
			;return false
		;/
	;/

	;return true
;/

# Using the type name and member name, create a label of form "_type.member"
/; construct_offset_label ({}charp t, {}charp n) [{}charp]
	;{}charp out = "_"
	;add_strings(~out, ~t)
	;out.append('.')
	;add_strings(~out, ~n)
	;return out
;/

/; construct_offset_value (int offset) [{}charp]
	;{}charp out = ".quad "
	;{}charp tmp = string_from_int(offset)
	;add_strings(~out, ~tmp)
	;return out
;/

# Parse a struct and add it to the table
/; def_struct (~int cur, ~{}Token data, ~{}charp dsec) [VType]
	;VType out = {0, 0, ""}
	;cur`++

	;{}charp a = "_"
	;add_strings(~a, data`{cur`}.data)
	;out.name = data`{cur`}.data`

	;cur`++
	;cur`++
	# Should be indexed at first type in the type list

	/; if (token_is(cur, data, "}"))
		;return NT
	;/

	;VType ctype = get_vtype(cur, data)
	;cur`++

	/; loop (cur` < len data`) [cur`++]
		/; if (token_is(cur, data, "}"))
			;break
		;; else if (token_is(cur, data, ","))
			;cur`++
		;/

		;cur`++
		/; if (token_is(cur, data, ",") || token_is(cur, data, "}"))
			# Use ctype
			;cur`--
			;{}charp l = construct_offset_label(out.name, data`{cur`}.data`)
			;l.append(':')
			;l.append(' ')
			;{}charp p = construct_offset_value(out._size)

			/; if (ctype.ptr > 0)
				;p = construct_offset_value(8)
				;out._size = out._size + 8
			;; else
				;out._size = out._size + ctype._size
			;/

			;p.append('\n')
			;add_strings(~l, ~p)
			# add "_type.member: .qword #offset_value" to data section
			
			;add_strings(dsec, ~l)
			
		;; else
			# Get type
			;cur`--
			;ctype = get_vtype(cur, data)
		;/
	;/

	;type_table.append(out)
	;return out
;/

# Checks if the current token's data is equal to a string
/; token_is(~int cur, ~{}Token data, {}charp str) [bool]
	;return string_equate(data`{cur`}.data`, str)
;/

# Skips in a definition or list until it finds a name
/; skip_to_name (~int cur, ~{}Token data)
	;int tmp = 0
	/; loop (cur` < len data`) [cur`++]
		;tmp = cur` + 1
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && 
				( token_is(~tmp, data, ",") || token_is(~tmp, data, ")") || token_is(~tmp, data, "}") || token_is(~tmp, data, ";") ))
			;break
		;/
	;/
;/

# Searches the type table for a type
/; vtype_by_name ({}charp name) [VType]
	/; loop (int i = 0; i < len type_table) [i++]
		;VType tmp = tnslc.type_table{i}
		/; if (string_equate(name, tmp.name))
			;return tmp
		;/
	;/
	;return NT
;/

# Parses a type in a definition or list
/; get_vtype (~int cur, ~{}Token data) [VType]
	;uint ptr = 0
	;VType out = NT

	/; loop (cur` < len data`) [cur`++]
		;int i = data`{cur`}.token_type
		/; if (token_is(cur, data, "~") || token_is(cur, data, "{"))
			;ptr++
		;; else if (i == TOKEN_TYPE.DEFWORD || i == TOKEN_TYPE.KEYTYPE)
			;out = vtype_by_name(data`{cur`}.data`)
			;break
		;; else if (!token_is(cur, data, "}"))
			;break
		;/
	;/

	;out.ptr = ptr

	;return out
;/

# Assumes cur points to the beginning of the arguments list
# Sets up the VTrack struct that is pointed to.
/; setup_vtrack (~int cur, ~{}Token data, ~VTrack tab)
	;cur`++

	;VType last = NT

	/; loop (cur` < len data`) [cur`++]
		;int pre_skip = cur`
		/; if (token_is(cur, data, ")"))
			;break
		;; else if (!token_is(cur, data, ","))
			;skip_to_name(cur, data)
			/; if (pre_skip == cur`)
				;tab`.sym_types.append(last)
				;tab`.sym_names.append(data`{cur`}.data`)
			;; else
				;last = get_vtype(~pre_skip, data)
				;tab`.sym_types.append(last)
				;tab`.sym_names.append(data`{cur`}.data`)
			;/
		;/
	;/
;/

# Mostly deals with structs and enums
/; compile_global (~int cur, ~{}Token data, ~VTrack gsc, ~{}charp hsec, csec, dsec)
	;cur`++
	/; if (token_is(cur, data, "struct"))
		;def_struct(cur, data, dsec)
	;/
;/

/; eval_value (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}charp hsec, csec, dsec, int reg)
	/; if (token_is(cur, data, ";/"))
		;return
	;/

	/; loop (cur` < len data`)
		/; if (data`{cur`}.token_type == TOKEN_TYPE.LITERAL)

		;; else if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD)
		
		;/
	;/
;/

# Sets up a call and reports back where the return value is stored
/; eval_call (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}charp hsec, csec, dsec) [{}charp]
	
		# Store the name of the function we are calling
	;{}charp to_call = data`{cur`}.data`

		# Set read head to first parameter
	;cur` = cur` + 2
	;int reg = 0
	/; loop (!token_is(cur, data, ")"))
		/; if (token_is(cur, data, ","))
			;cur`++
		;; else
			/; if (reg < 7)
				;eval_value(cur, data, tab, gsc, hsec, csec, dsec, reg)
				;reg++
			;; else
				;eval_value(cur, data, tab, gsc, hsec, csec, dsec, reg)
				;push_asm(get_reg(8, "bp"))
			;/
		;/
	;/

	;{}charp call_ist = call_asm(to_call)

	;add_strings(csec, ~call_ist)
	;return "ax"
;/

/; set_value ({}charp from, to, int size, ~{}charp csec)
	/; if (is_common_reg(from))
		;from = get_reg(size, from)
	;; if (is_common_reg(to))
		;to = get_reg(size, to)
	;/

	;{}charp tmp = "\tmov"
	/; if (size == 1)
		;mov.append('b')
	;; else if (size == 2)
		;mov.append('d')
	;; else if (size == 4)
		;mov.append('w')
	;; else if (size == 8)
		;mov.append('q')
	;/

	;tmp = construct_statement(tmp, {from, to})
	;add_strings(csec, ~tmp)
;/

# Compile a statement in a function
/; compile_statement (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}charp hsec, csec, dsec) [bool]
	;cur`++
	;bool r = false
	/; if (cur` < len data`)
		/; if (token_is(cur, data, "asm"))
			;cur`++
			;{}charp raw_asm = unquote_string(data`{cur`}.data`)
			;raw_asm.append('\n')
			;csec`.append('\t')
			;add_strings(csec, ~raw_asm)
		;; else if (token_is(cur, data, "raw"))
			;cur`++
			;r = true
		;; else if (token_is(cur, data, "return"))
			;cur`++
			;eval_value(cur, data, tab, gsc, hsec, csec, dsec, 0)
			;tail_guard(csec)
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;return true
		;; else if (string_equate(data`{cur`+1}.data`, "("))
			# Function call
			;eval_call(cur, data, tab, gsc, hsec, csec, dsec)
		;; else if (name_to_index(data`{cur`}.data`, tab) !< 0)
			# set value
			;int i = name_to_index(data`{cur`}.data`, tab)
			;{}charp tmp = index_to_loc(i)
			;eval_value(cur, data, tab, gsc, hsec, csec, dsec, 0)
			;tmp = mov_asm(get_reg(tab`.sym_types{i}._size, "ax"), tmp)
			;add_strings(csec, ~tmp)
		;; else
			#Definition
			;VType def_t = get_vtype(cur, data)
			;cur`++
			
			/; loop (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD)
				;tab`.sym_types.append(def_t)
				;tab`.sym_names.append(data`{cur`}.data`)
				/; if (token_is(cur, data, ","))
					;cur`++
				;; else if (token_is(cur, data, "="))
					;{}charp loc = index_to_loc(len tab`.sym_names - 1, tab)
					;eval_value(cur, data, tab, gsc, hsec, csec, dsec, loc)
					/; if (token_is(cur, data, ","))
						;cur`++
					;/
				;/
			;/
			/; if (string_equate(data`{cur`+1}.data`, "="))

			;/
		;; if (token_is(cur, data, "return"))
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;return true
		;/
	;/

	;return false
;/



/; compile_block (~int cur, ~{}Token data, ~VTrack gsc, ~{}charp hsec, csec, dsec)
	;VTrack tab = { {}, {} }
	;VType out_type = NT
	;{}charp name = ""
	;bool r = false

	/; loop (cur`++; cur` < len data`) [cur`++]
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && len name == 0)
			;name = data`{cur`}.data`
			;add_strings(csec, ~name)
			;csec`.append(':')
			;csec`.append('\n')
		;; else if (token_is(cur, data, "("))
			;setup_vtrack(cur, data, ~tab)
		;; else if (token_is(cur, data, "["))
			;cur`++
			;out_type = get_vtype(cur, data)
			;cur`++
		;; else if (token_is(cur, data, "raw"))
			;r = true
		;; else
			;break
		;/
	;/

	;tnsl.io.println(out_type.name)

	/; if (!r)
		;header_guard(csec)
	;/

	;bool ret = false
	/; loop (cur` < len data` && !ret) [cur`++]
		/; if (string_equate(data`{cur`}.data`, ";/"))
			/; if (!r)
				;tail_guard(csec)
			;/
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;break
		;; else if (string_equate(data`{cur`}.data`, "/;"))
			;bool ch = true
			/; loop (ch)
				;compile_block(cur, data, gsc, hsec, csec, dsec)
				/; if (cur` !< len data`)
					;break
				;/
				;ch = string_equate(data`{cur`}.data`, ";;")
			;/			
		;; else if (string_equate(data`{cur`}.data`, ";"))
			;ret = compile_statement(cur, data, ~tab, gsc, hsec, csec, dsec)
		;; else
			;tnsl.io.print("Failed to compile token [compile_block]: ")
			;data`{cur`}.print()
			;tnsl.io.println("")
			;break
		;/
	;/

	;csec`.append('\n')
;/

/; do_compile ({}charp file, ~{}Token data)
	;{}charp hsec = ".global main\n"
	;{}charp csec = ".text\n"
	;{}charp dsec = ".data\n"

	;int j = len data`
	
	;VTrack global_scope = {{}, {}}

	/; loop (int i = 0; i < j) [i++]
		/; if (string_equate(data`{i}.data`, "/;"))
			;compile_block(~i, data, ~global_scope, ~hsec, ~csec, ~dsec)
		;; else if (string_equate(data`{i}.data`, ";"))
			;compile_global(~i, data, ~global_scope, ~hsec, ~csec, ~dsec)
		;; else
			;break
		;/
	;/

	;tnsl.io.File out = tnsl.io.writeFile(file)
	
	/; loop (int i = 0; i < len hsec) [i++]
		;out.write(hsec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len csec) [i++]
		;out.write(csec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len dsec) [i++]
		;out.write(dsec{i})
	;/

	;out.write('\n')
	;out.close()
;/

