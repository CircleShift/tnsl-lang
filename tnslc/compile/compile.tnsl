/##
	Copyright 2021-2022 Kyle Gunger

	This file is licensed under the CDDL 1.0 (the License)
	and may only be used in accordance with the License.
	You should have received a copy of the License with this
	software/source code. If you did not, a copy can be found
	at the following URL:

	https://opensource.org/licenses/CDDL-1.0

	THIS SOFTWARE/SOURCE CODE IS PROVIDED "AS IS" WITH NO
	WARRANTY, GUARANTEE, OR CLAIM OF FITNESS FOR ANY PURPOSE
	EXPRESS OR IMPLIED
#/


;{}{}charp COMMON_ASM = {
	"\tret",
	"\tpush %",
	"\tpop %"
}

;struct VType {
	uint _size,
	{}charp name
}

;struct VTrack {
	{}{}charp
		sym_names,
	
	{}VType
		sym_types
}

# Null type
;VType NT = {0, "null"}

/; name_to_index ({}charp name, ~VTrack tab) [int]
	/; loop (int i = 0; i < len tab`.sym_names) [i++]
		/; if (string_equate(tab`.sym_names{i}, name))
			;return i
		;/
	;/

	;tnsl.io.print("Failed to find vairable ")
	;tnsl.io.println(name)

	;return -1
;/

/; index_to_loc (int index, ~VTrack tab) [{}charp]
	;{}charp out = ""
	;int stack_bytes = 0
	;int reg = 0
	;int i = 0

	/; loop (i < index) [i++]
		/; if (tab`.sym_types{i}._size !> 8 && reg < 7)
			;reg++
		;; else
			;stack_bytes = stack_bytes + tab`.sym_types{i}._size
		;/
	;/
	
;/

/; token_is(~int cur, ~{}Token data, {}charp str) [bool]
	;return string_equate(data`{cur`}.data`, str)
;/

/; setup_vtrack (~int cur, ~{}Token data, ~VTrack tab)
	;cur`++

	/; loop (cur` < len data`) [cur`++]
		/; if (token_is(cur, data, ")"))
			;break
		;; 
		;/
	;/
;/

/; compile_statement (~int cur, ~{}Token data, ~{}charp hsec, csec, dsec)
	;cur`++
	/; if (cur` < len data`)
		/; if (token_is(cur, data, "asm"))
			;cur`++
			;{}charp raw_asm = unquote_string(data`{cur`}.data`)
			;raw_asm.append('\n')
			;csec`.append('\t')
			;add_strings(csec, ~raw_asm)
		;/
	;/
;/

/; compile_block (~int cur, ~{}Token data, ~{}charp hsec, csec, dsec)
	;VTrack tab = {
		{},
		{}
	}

	;{}charp name = {}
	;bool r = false
	/; loop (cur`++; cur` < len data`) [cur`++]
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && len name == 0)
			;name = data`{cur`}.data`
			;add_strings(csec, ~name)
			;csec`.append(':')
			;csec`.append('\n')
		;; else if (token_is(cur, data, "("))
			;setup_vtrack(cur, data, ~tab)
		;; else if (token_is(cur, data, "["))
			/; loop (cur`++; cur` < len data`) [cur`++]
				/; if (token_is(cur, data, "]"))
					;break
				;/
			;/
		;; else if (token_is(cur, data, "raw"))
			;r = true
		;; else
			;break
		;/
	;/

	/; if (!r)
		;header_guard(tab, csec)
	;/

	/; loop (cur` < len data`) [cur`++]
		/; if (string_equate(data`{cur`}.data`, ";/"))
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;break
		;; else if (string_equate(data`{cur`}.data`, "/;"))
			;bool ch = true
			/; loop (ch)
				;compile_block(cur, data, hsec, csec, dsec)
				/; if (cur` !< len data`)
					;break
				;/
				;ch = string_equate(data`{cur`}.data`, ";;")
			;/			
		;; else if (string_equate(data`{cur`}.data`, ";"))
			;compile_statement(cur, data, hsec, csec, dsec)
		;; else
			;tnsl.io.print("Failed to compile token [compile_block]: ")
			;data`{cur`}.print()
			;tnsl.io.println("")
			;break
		;/
	;/

	/; if (!r)
		;tail_guard(csec)
	;/

	;csec`.append('\n')
;/

/; do_compile ({}charp file, ~{}Token data)
	;{}charp hsec = ".global main\n"
	;{}charp csec = ".text\n"
	;{}charp dsec = ".data\n"

	;int j = len data`
	/#
	/; loop (int i = 0; i < j) [i++]
		/; if (string_equate(data`{i}.data`, "/;"))
			;compile_block(~i, data, ~hsec, ~csec, ~dsec)
		;; else if (string_equate(data`{i}.data`, ";"))
			;compile_statement(~i, data, ~hsec, ~csec, ~dsec)
		;; else
			;break
		;/
	;/
	#/
	;{}charp tmp = add_asm("%eax", "%edx")
	;add_strings(~csec, ~tmp)

	;tnsl.io.File out = tnsl.io.writeFile(file)
	
	/; loop (int i = 0; i < len hsec) [i++]
		;out.write(hsec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len csec) [i++]
		;out.write(csec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len dsec) [i++]
		;out.write(dsec{i})
	;/

	;out.write('\n')
	;out.close()
;/

