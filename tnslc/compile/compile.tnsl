/##
	Copyright 2021 Kyle Gunger

	This file is licensed under the CDDL 1.0 (the License)
	and may only be used in accordance with the License.
	You should have received a copy of the License with this
	software/source code. If you did not, a copy can be found
	at the following URL:

	https://opensource.org/licenses/CDDL-1.0

	THIS SOFTWARE/SOURCE CODE IS PROVIDED "AS IS" WITH NO
	WARRANTY, GUARANTEE, OR CLAIM OF FITNESS FOR ANY PURPOSE
	EXPRESS OR IMPLIED
#/

/; module compile
	# :include "compile/arch/arch.tnsl"
	:include "compile/isa_x86.tnsl"
	# :include "compile/comp.tnsl"
;/


;{}{}charp COMMON_ASM = {
	"\tret",
	"push %",
	"pop %"
}

;struct VType {
	uint _size,
	{}charp name
}

;struct VTrack {
	{}{}charp
		sym_names,
	
	{}VType
		sym_types
}

# Null type
;VType NT = {0, "null"}

/; find_var ({}charp name, ~VTrack tab) [{}charp]
	/; loop (int i = 0; i < 8) [i++]
		/; if (string_equate(tab`.sym_names{i}, name))
			;{}charp out = "r"
			;{}charp n = string_from_int(i + 8)
			;add_strings(~out, ~n)
			/; if (tab`.sym_sizes{i}._size == 4)
				;out.append('d')
			;; else if (tab`.sym_sizes{i}._size == 2)
				;out.append('w')
			;; else if (tab`.sym_sizes{i}._size == 1)
				;out.append('b')
			;/
			;return out
		;/
	;/

	;tnsl.io.print("Failed to find vairable ")
	;tnsl.io.println(name)
;/

/; token_is(~int cur, ~{}Token data, {}charp str) [bool]
	;return string_equate(data`{cur`}.data`, str)
;/

/; setup_vtrack (~int cur, ~{}Token data, ~VTrack tab)
	;cur`++

	/; loop (cur` < len data`) [cur`++]
		/; if (token_is(cur, data, ")"))
			;break
		;; 
		;/
	;/
;/

/; header_guard (~VTrack tab, ~{}charp csec)

;/

/; ret_guard (~VTrack tab, {}charp to_ret, ~{}charp csec)
	;tail_guard(csec)

;/

/; tail_guard (~{}charp csec)
;/

/; compile_statement (~int cur, ~{}Token data, ~{}charp hsec, csec, dsec)
	;cur`++
	/; if (cur` < len data`)
		/; if (token_is(cur, data, "asm"))
			;cur`++
			;{}charp raw_asm = unquote_string(data`{cur`}.data`)
			;raw_asm.append('\n')
			;csec`.append('\t')
			;add_strings(csec, ~raw_asm)
		;/
	;/
;/

/; compile_block (~int cur, ~{}Token data, ~{}charp hsec, csec, dsec)
	;VTrack tab = {
		{"", "", "", "", "", "", "", ""},
		{NT, NT, NT, NT, NT, NT, NT, NT}
	}

	;{}charp name = {}
	;bool r = false
	/; loop (cur`++; cur` < len data`) [cur`++]
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && len name == 0)
			;name = data`{cur`}.data`
			;add_strings(csec, ~name)
			;csec`.append(':')
			;csec`.append('\n')
		;; else if (token_is(cur, data, "("))
			;setup_vtrack(cur, data, ~tab)
		;; else if (token_is(cur, data, "["))
			/; loop (cur`++; cur` < len data`) [cur`++]
				/; if (token_is(cur, data, "]"))
					;break
				;/
			;/
		;; else if (token_is(cur, data, "raw"))
			;r = true
		;; else
			;break
		;/
	;/

	/; if (!r)
		;header_guard(tab, csec)
	;/

	/; loop (cur` < len data`) [cur`++]
		/; if (string_equate(data`{cur`}.data`, ";/"))
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;break
		;; else if (string_equate(data`{cur`}.data`, "/;"))
			;bool ch = true
			/; loop (ch)
				;compile_block(cur, data, hsec, csec, dsec)
				/; if (cur` !< len data`)
					;break
				;/
				;ch = string_equate(data`{cur`}.data`, ";;")
			;/			
		;; else if (string_equate(data`{cur`}.data`, ";"))
			;compile_statement(cur, data, hsec, csec, dsec)
		;; else
			;tnsl.io.print("Failed to compile token [compile_block]: ")
			;data`{cur`}.print()
			;tnsl.io.println("")
			;break
		;/
	;/

	/; if (!r)
		;tail_guard(csec)
	;/

	;csec`.append('\n')
;/

/; do_compile ({}charp file, ~{}Token data)
	;{}charp hsec = ".global main\n"
	;{}charp csec = ".text\n"
	;{}charp dsec = ".data\n"

	;int j = len data`

	/; loop (int i = 0; i < j) [i++]
		/; if (string_equate(data`{i}.data`, "/;"))
			;compile_block(~i, data, ~hsec, ~csec, ~dsec)
		;; else if (string_equate(data`{i}.data`, ";"))
			;compile_statement(~i, data, ~hsec, ~csec, ~dsec)
		;; else
			;break
		;/
	;/

	;tnsl.io.File out = tnsl.io.writeFile(file)
	
	/; loop (int i = 0; i < len hsec) [i++]
		;out.write(hsec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len csec) [i++]
		;out.write(csec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len dsec) [i++]
		;out.write(dsec{i})
	;/

	;out.write('\n')
	;out.close()
;/

