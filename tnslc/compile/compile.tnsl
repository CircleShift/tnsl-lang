/##
	Copyright 2021-2022 Kyle Gunger

	This file is licensed under the CDDL 1.0 (the License)
	and may only be used in accordance with the License.
	You should have received a copy of the License with this
	software/source code. If you did not, a copy can be found
	at the following URL:

	https://opensource.org/licenses/CDDL-1.0

	THIS SOFTWARE/SOURCE CODE IS PROVIDED "AS IS" WITH NO
	WARRANTY, GUARANTEE, OR CLAIM OF FITNESS FOR ANY PURPOSE
	EXPRESS OR IMPLIED
#/


;{}{}uint8 COMMON_ASM = {
	"\tret\n"
}

# Represents a type
;struct VType {
	uint
		_size,
	int
		ptr,
	
	{}uint8 name,

	{}VType sub_types,
	{}{}uint8 sub_names
}

/; method VType
	/; get_sub_type({}uint8 name) [VType]
		/; loop (int i = 0; i < len (self.sub_types)) [i++]
			/; if (string_equate(~name, ~(self.sub_names{i})))
				;return self.sub_types{i}
			;/
		;/
		;return NT
	;/

	/; get_offset({}uint8 name) [int]
		;int out = 0
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (string_equate(~name, ~(self.sub_types{i*2 + 1})))
				;return out
			;; else if (self.on_stack{i})
				;VType tmp = vtype_by_name(self.sub_types{i*2})
				;out = out + tmp.size
			;/
		;/
		;return -1
	;/

	/; print
		;tnsl.io.print("Size: ")
		;tnsl.io.print(self._size)
		;tnsl.io.print(" | Ptr: ")
		;tnsl.io.print(self.ptr)
		;tnsl.io.print(" | Name: ")
		;tnsl.io.println(self.name)
	;/
;/

# Tracks defined variables in a block
;struct VTrack {
	{}{}uint8
		sym_names,

	{}Value
		sym_vals
}

/; method VTrack

	/; next_loc(VType vt) [int]
		/; if (is_struct(vt))
			;return -1
		;/

		;int count = 0
		/; loop (int i = 0; i < len (self.sym_vals)) [i++]
			/; if (!(self.sym_vals{i}.on_stack))
				;count++
			;/

			/; if (count > 7)
				;return -1
			;/
		;/

		;return count + 6
	;/

	# returns with init commands
	/; add_track({}uint8 name, VType _type) [{}uint8]
		;Value v = track_val(_type, to_stack, self.next_loc(_type))
		
		/; if (v.loc < 0)
			;v.loc = 0
		;/

		;self.sym_names.append(name)
		;self.sym_vals.append(v)
		;return v.init_val()
	;/

	# Returns true if the variable is being tracked
	/; in_vtrack({}uint8 name) [bool]
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (string_equate(~name, ~(self.sym_names{i})))
				;return true
			;/
		;/
		;return false
	;/

	# Returns the total allocated memory on the stack for this tracker
	/; stack_total [int]
		;int out = 0
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (self.on_stack{i})
				;out = out + (self.sym_vals{i}._type._size)
			;/
		;/
		;return out
	;/

	# returns the type of the named variable
	/; get_val ({}uint8 name) [Value]
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (string_equate(name, self.sym_names{i}))
				;return (self.sym_vals{i})
			;/
		;/
	;/

	# push stack updates loc for every value on the stack
	/; push_stack (VType vt) [{}uint8]
		;int tsz = vt._size
		/; if (vt.ptr !== 0)
			;tsz = 8
		;/

		/; loop (int i = 0; i < len (self.sym_vals)) [i++]
			;self.sym_vals{i}.loc = self.sym_vals{i}.loc + tsz
		;/

		;{}uint8 out = "\tsub $"
		;{}uint8 tmp = string_from_int(tsz)
		;add_strings(~out, ~tmp)
		;out.append(',')
		;out.append(' ')
		;tmp = "%rsp"
		;add_strings(~out, ~tmp)
		;return out
	;/
;/

# Sizes of items
;{}VType type_table = {
	{1, 0, "int8", {}, {}},
	{2, 0, "int16", {}, {}},
	{4, 0, "int32", {}, {}},
	{8, 0, "int64", {}, {}},
	{8, 0, "int", {}, {}},
	{1, 0, "uint8", {}, {}},
	{2, 0, "uint16", {}, {}},
	{4, 0, "uint32", {}, {}},
	{8, 0, "uint64", {}, {}},
	{8, 0, "uint", {}, {}},
	{4, 0, "float32", {}, {}},
	{8, 0, "float64", {}, {}},
	{8, 0, "float", {}, {}},
	{1, 0, "bool", {}, {}},
	{8, 0, "void", {}, {}}
}

# Null type
;VType NT = {0, 0, "null", {}, {}}

# Returns an index in the vtrack for a given variable name
/; name_to_index ({}uint8 name, ~VTrack tab) [int]
	/; loop (int i = 0; i < len (tab`.sym_names)) [i++]
		/; if (string_equate(tab`.sym_names{i}, name))
			;return i
		;/
	;/
	
	;tnsl.io.print("Failed to find vairable ")
	;tnsl.io.println(name)

	;return -1
;/

# Given an index in the vtrack, returns a string representation of the
# register or memory where that variable is
/; index_to_loc (int index, ~VTrack tab) [{}uint8]
	;{}uint8 out = ""
	;int stack_bytes = 0
	;int reg = 0
	;int i = 0

	/; loop (i < index) [i++]
		/; if (tab`.sym_types{i}._size !> 8 && reg < 7)
			;reg++
		;; else
			;stack_bytes = stack_bytes + tab`.sym_types{i}._size
		;/
	;/

	/; if (is_struct(tab`.sym_types{index}))
		;out = "(todo: structs)"
	;; else
		;out = reg_by_num(reg)
	;/
	
	;return out
;/

# Bool to j
/; cmp_to_jxt ({}uint8 c) [{}uint8]
	/; if (string_equate(c, "<"))
		;return "l"
	;;	else if (string_equate(c, ">"))
		;return "g"
	;;	else if (string_equate(c, "!<") || string_equate(c, ">=="))
		;return "nl"
	;;	else if (string_equate(c, "!>") || string_equate(c, "<=="))
		;return "ng"
	;;	else if (string_equate(c, "=="))
		;return "e"
	;;	else if (string_equate(c, "!=="))
		;return "ne"
	;; 
	;/
	;return "nz"
;/

# Is struct returns true if the type name given is a struct
/; is_struct (VType t) [bool]
	/; if (t.ptr !== 0)
		;return false
	;/

	;VType tmp = NT
	/; loop (int i = 0; i < 15) [i++]
		;tmp = tnslc.type_table{i}
		/; if (string_equate(tmp.name, t.name))
			;return false
		;/
	;/

	

	;return true
;/

# Using the given offset (in bytes), return an asm value of form ".quad <offset>"
/; construct_value (int size, int offset) [{}uint8]
	;{}uint8 out = ".byte "
	/; if (size == 2)
		;out = ".word "
	;; if (size == 4)
		;out = ".long"
	;; if (size == 8)
		;out = ".quad "
	;/
	;{}uint8 tmp = string_from_int(offset)
	;add_strings(~out, ~tmp)
	;return out
;/

/; construct_text_value ({}uint8 t) [{}uint8]
	;{}uint8 tmp = "\n\t.ascii "
	;add_strings(~tmp, ~t)
	;return tmp
;/

/; construct_mov_literal({}uint8 value, reg) [{}uint8]
	;{}uint8 tmp = "$"
	;add_strings(~tmp, ~value)
	;return mov_asm(tmp, reg)
;/

# Parse a struct and add it to the table
/; def_struct (~int cur, ~{}Token data, ~{}uint8 dsec) [VType]
	;VType out = {0, 0, "", {}, {}}
	;cur`++

	;out.name = data`{cur`}.data`

	;cur`++
	;cur`++
	# Should be indexed at first type in the type list

	/; if (token_is(cur, data, "}"))
		;return NT
	;/

	;VType ctype = get_vtype(cur, data)
	;cur`++

	/; loop (cur` < len data`) [cur`++]
		/; if (token_is(cur, data, "}"))
			;break
		;; else if (token_is(cur, data, ","))
			;cur`++
		;/

		;cur`++
		/; if (token_is(cur, data, ",") || token_is(cur, data, "}"))
			# Use ctype
			;cur`--

			/; if (ctype.ptr > 0)
				;out._size = out._size + 8
			;; else
				;out._size = out._size + ctype._size
			;/
			;out.sub_types.append(ctype)
			;out.sub_names.append(data`{cur`}.data`)
			
		;; else
			# Get type
			;cur`--
			;ctype = get_vtype(cur, data)
		;/
	;/
	;out.print()
	;type_table.append(out)
	
	;return out
;/

# Checks if the current token's data member is equal to a given string
/; token_is(~int cur, ~{}Token data, {}uint8 str) [bool]
	;return string_equate(data`{cur`}.data`, str)
;/

# Skips in a definition or list until it finds a name
/; skip_to_name (~int cur, ~{}Token data)
	;int tmp = 0
	/; loop (cur` < len data`) [cur`++]
		;tmp = cur` + 1
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && 
				( token_is(~tmp, data, ",") || token_is(~tmp, data, ")") || token_is(~tmp, data, "}") || token_is(~tmp, data, ";") ))
			;break
		;/
	;/
;/

# Searches the type table for a type
/; vtype_by_name ({}uint8 name) [VType]
	/; loop (int i = 0; i < len type_table) [i++]
		;VType tmp = tnslc.type_table{i}
		/; if (string_equate(name, tmp.name))
			;return tmp
		;/
	;/
	;return NT
;/

# Parses a type in a definition or list
/; get_vtype (~int cur, ~{}Token data) [VType]
	;uint ptr = 0
	;VType out = NT

	/; loop (cur` < len data`) [cur`++]
		;int i = data`{cur`}.token_type
		/; if (token_is(cur, data, "~") || token_is(cur, data, "{"))
			;ptr++
		;; else if (i == TOKEN_TYPE.DEFWORD || i == TOKEN_TYPE.KEYTYPE)
			;out = vtype_by_name(data`{cur`}.data`)
			;break
		;; else if (!token_is(cur, data, "}"))
			;break
		;/
	;/

	;out.ptr = ptr

	;return out
;/

# Assumes cur points to the beginning of the arguments list
# Sets up the VTrack struct that is pointed to.
/; setup_vtrack (~int cur, ~{}Token data, ~VTrack tab, ~{}uint8 csec)
	;cur`++

	;VType last = NT
	;Value tmp = {false, false, 0, 0, last}

	/; loop (cur` < len data`) [cur`++]
		;int pre_skip = cur`
		/; if (token_is(cur, data, ")"))
			
			;break
		;; else if (!token_is(cur, data, ","))
			
			;skip_to_name(cur, data)
			
			/; if (pre_skip !== cur`)
				;last = get_vtype(~pre_skip, data)
				;tmp._type = last
			;/
			
			;tab`.sym_names.append(data`{cur`}.data`)
			;int nloc = tab`.next_loc(last)
			
			;Value store = {false, false, nloc, 0, last}
			/; if (store.loc !< 0 && tmp.loc !> 5)
				;{}uint8 tstr = store.set_value(tmp)
				;add_strings(csec, ~tstr)
				;tmp.loc = tmp.loc + 1
			;; else
				;store.loc = 0
				;store.on_stack = true
				;tab`.push_stack(last)
			;/

			;tab`.sym_vals.append(store)
		;/
	;/
;/

# Mostly deals with structs and enums
/; compile_global (~int cur, ~{}Token data, ~VTrack gsc, ~{}uint8 hsec, csec, dsec)
	;cur`++
	/; if (token_is(cur, data, "struct"))
		;def_struct(cur, data, dsec)
	;/
;/

# Evaluate a value and return it to the register pointed at by reg
/; eval_value (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}uint8 hsec, csec, dsec) [Value]
	/; if (token_is(cur, data, ";/"))
		;return NV
	;/

	;int val_layer = 0

	/; loop (cur` < len data`)
		/; if (data`{cur`}.token_type == TOKEN_TYPE.LITERAL)
			/; if (data`{cur`}.data`{0} == '"')
				# String literal
			
			;; else if (data`{cur`}.data`{0} == '\'')
				# Char literal
			;; else
				# int literal
				;{}uint8 tmp = construct_mov_literal(data`{cur`}.data`, get_reg(8, reg_by_num(val_layer)))
				;add_strings(csec, ~tmp)
				;val_layer++
				;cur`++
			;/
		;; else if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD)
		;; else if (token_is(cur, data, "~"))
		;; else if (data`{cur`}.token_type == TOKEN_TYPE.AUGMENT)
		;; else
			;break
		;/
	;/
;/

/; get_function_label(~int cur, ~{}Token data) [{}uint8]
	/; if (string_equate(data`{cur` + 1}.data`, "("))
		;return data`{cur`}.data`
	;/

	;{}{}uint8 func_path = {}

	/; loop (cur` < len data`) [cur`++]
		/; if (token_is(cur, data, "("))
			;break
		;; else if (!token_is(cur, data, "."))
			;func_path.append(data`{cur`}.data`)
		;/
	;/
	;{}uint8 out = "_."
	;{}uint8 jn_tmp = join(func_path, '.')
	;add_strings(~out, ~jn_tmp)
	;return out
;/

# Sets up a call and reports back where the return value is stored
/; eval_call (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}uint8 hsec, csec, dsec) [{}uint8]
	
		# Store the name of the function we are calling
	;{}uint8 to_call = get_function_label(cur, data)
	;tnsl.io.println(to_call)
		# Set read head to first parameter
	;cur`++
	/; loop (!token_is(cur, data, ")"))
		/; if (token_is(cur, data, ","))
			;cur`++
		;; else
			/; if (reg < 7)
				;eval_value(cur, data, tab, gsc, hsec, csec, dsec)
				;reg++
			;; else
				;eval_value(cur, data, tab, gsc, hsec, csec, dsec)
				;push_asm(get_reg(8, "bp"))
			;/
		;/
	;/
	;cur`++

	;{}uint8 call_ist = call_asm(to_call)

	;add_strings(csec, ~call_ist)
	;return "ax"
;/

/; set_struct_value (~{}uint8 csec)

;/

/; copy_struct ({}uint8 from, to, VType t) [{}uint8]
	;{}uint8 out = ""
	;{}uint8 init = ""
;/

/; set_value ({}uint8 from, to, int size, ~{}uint8 csec)
	/; if (is_common_reg(from))
		;from = get_reg(size, from)
	;; if (is_common_reg(to))
		;to = get_reg(size, to)
	;/

	;{}uint8 tmp = "\tmov"
	/; if (size == 1)
		;mov.append('b')
	;; else if (size == 2)
		;mov.append('d')
	;; else if (size == 4)
		;mov.append('w')
	;; else if (size == 8)
		;mov.append('q')
	;/

	;tmp = construct_statement(tmp, {from, to})
	;add_strings(csec, ~tmp)
;/

/; is_call (~int cur, ~{}Token data) [bool]
	;bool look_def = true
	/; loop (int i = cur`; i < len data`) [i++]
		/; if (look_def && data`{i}.token_type == TOKEN_TYPE.DEFWORD)
			;look_def = false
		;; else if (!look_def && token_is(~i, data, "."))
			;look_def = true
		;; else if (!look_def && token_is(~i, data, "("))
			;return true
		;; else
			;break
		;/
	;/
	;return false
;/

# Compile a statement in a function
/; compile_statement (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}uint8 hsec, csec, dsec) [bool]
	;cur`++
	;bool r = false
	/; if (cur` !< len data`)
		;return false
	;/

	/; if (token_is(cur, data, "asm"))
		;cur`++
		;{}uint8 raw_asm = unquote_string(data`{cur`}.data`)
		;raw_asm.append('\n')
		;csec`.append('\t')
		;add_strings(csec, ~raw_asm)
		;cur`++
	;; else if (token_is(cur, data, "raw"))
		;cur`++
		;r = true
	;; else if (token_is(cur, data, "return"))
		;cur`++
		;eval_value(cur, data, tab, gsc, hsec, csec, dsec, 0)
		;tail_guard(csec)
		;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
		;return true
	;; else if (is_call(cur, data))
		# Function call
		;eval_call(cur, data, tab, gsc, hsec, csec, dsec)
	;; else if (name_to_index(data`{cur`}.data`, tab) !< 0)
		# set value
		;int i = name_to_index(data`{cur`}.data`, tab)
		;{}uint8 tmp = index_to_loc(i)
		;eval_value(cur, data, tab, gsc, hsec, csec, dsec)
		;tmp = mov_asm(get_reg(tab`.sym_types{i}._size, "ax"), tmp)
		;add_strings(csec, ~tmp)
	;; else
		#Definition
		;VType def_t = get_vtype(cur, data)
		;cur`++
		
		/; loop (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD)
			;{}uint8 init = tab`.add_track(data`{cur`}.data`, def_t)
			;add_strings(~out, ~init)
			;cur`++
			/; if (token_is(cur, data, ","))
				;cur`++
			;; else if (token_is(cur, data, "="))
				;{}uint8 set = index_to_loc(len tab`.sym_names - 1, tab)
				;eval_value(cur, data, tab, gsc, hsec, csec, dsec, loc)
				/; if (token_is(cur, data, ","))
					;cur`++
				;/
			;; else
				;break
			;/
		;/
		/; if (string_equate(data`{cur`+1}.data`, "="))
		;/
	;; if (token_is(cur, data, "return"))
		;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
		;return true
	;/

	;return false
;/



/; compile_block (~int cur, ~{}Token data, ~VTrack gsc, ~{}uint8 hsec, csec, dsec, {}{}uint8 mod_path, Path rel)
	;VTrack tab = { {}, {} }
	;VType out_type = tnslc.type_table{14}
	;{}uint8 name = ""
	;bool r = false

	/; loop (cur`++; cur` < len data`) [cur`++]
		/; if (token_is(cur, data, "module"))
			;mod_path.append(data`{cur` + 1}.data`)
			;cur` = cur` + 2
			;break
		;/
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && len name == 0)
			;name = data`{cur`}.data`
			/; if (len mod_path > 0)
				;{}uint8 frs = "_."
				;{}uint8 jn = join(mod_path, '.')
				;add_strings(~frs, ~jn)
				;add_strings(csec, ~frs)
				;csec`.append('.')
			;/
			;add_strings(csec, ~name)
			;csec`.append(':')
			;csec`.append('\n')
			/; if (!r)
				;header_guard(csec)
			;/
		;; else if (token_is(cur, data, "("))
			;setup_vtrack(cur, data, ~tab, csec)
		;; else if (token_is(cur, data, "["))
			;cur`++
			;out_type = get_vtype(cur, data)
			;cur`++
		;; else if (token_is(cur, data, "raw"))
			;r = true
		;; else
			;break
		;/
	;/

	;tnsl.io.println(out_type.name)

	;bool ret = false
	/; loop (cur` < len data` && !ret)
		/; if (token_is(cur, data, ";/"))
			/; if (!r)
				;tail_guard(csec)
			;/
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;break
		;; else if (token_is(cur, data, "/;"))
			;bool ch = true
			/; loop (ch)
				;compile_block(cur, data, gsc, hsec, csec, dsec, mod_path)
				/; if (cur` !< len data`)
					;break
				;/
				;ch = token_is(cur, data, ";;")
			;/
		;; else if (string_equate(data`{cur`}.data`, ":"))
			;cur` = cur` + 2
			;Path inc = rel.rel_file(unquote_string(data`{cur`}.data`))
			;compile_include(inc, gsc, hsec, csec, dsec, mod_path)
			;cur`++
		;; else if (string_equate(data`{cur`}.data`, ";"))
			;ret = compile_statement(cur, data, ~tab, gsc, hsec, csec, dsec)
		;; else
			;tnsl.io.print("Failed to compile token [compile_block]: ")
			;data`{cur`}.print()
			;tnsl.io.println("")
			;break
		;/
	;/

	;csec`.append('\n')
;/

/; compile_include (Path file_path, ~VTrack global, ~{}uint8 hsec, csec, dsec, {}{}uint8 mod_path)
	# Autocomplete in the case of module syntax
	;bool d = file_path.extension_is("tnsl")
	/; if (!d)
		;file_path.dirs.append(file_path.file)
		;{}uint8 ftmp = file_path.file
		;{}uint8 tmp = ".tnsl"
		;add_strings(~ftmp, ~tmp)
		;file_path.file = ftmp
	;/

	;tnsl.io.print("[TNSLC:INCLUDE] ")
	;tnsl.io.println(file_path.full_path())

	;tnsl.io.File inc = file_path.open_r()
	;~{}Token data = parse.tokenize(inc)
	;inc.close()

	;tnsl.io.print(len data`)
	;tnsl.io.println(" tokens parsed.")
	
	;compile_file(file_path, data, global, hsec, csec, dsec, mod_path)
;/

/; compile_file (Path rel, ~{}Token data, ~VTrack global, ~{}uint8 hsec, csec, dsec, {}{}uint8 mod_path)
	
	;int j = len data`

	/; loop (int i = 0; i < j) [i++]
		/; if (string_equate(data`{i}.data`, "/;"))
			;compile_block(~i, data, global, hsec, csec, dsec, mod_path, rel)
		;; else if (string_equate(data`{i}.data`, ";"))
			;compile_global(~i, data, global, hsec, csec, dsec)
		;; else if (string_equate(data`{i}.data`, ":"))
			;i = i + 2
			;Path inc = rel.rel_file(unquote_string(data`{i}.data`))
			;compile_include(inc, global, hsec, csec, dsec, mod_path)
		;; else
			;break
		;/
	;/

;/

/; do_compile ({}uint8 file_out, Path rel)
	;{}uint8 hsec = ".global main\n"
	;{}uint8 csec = ".text\n"
	;{}uint8 dsec = ".data\n"
	
	;VTrack global_scope = {{}, {}}

	;tnslc.compile_include(rel, ~global_scope, ~hsec, ~csec, ~dsec, {})

	;tnsl.io.File out = tnsl.io.writeFile(file_out)
	
	/; loop (int i = 0; i < len hsec) [i++]
		;out.write(hsec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len dsec) [i++]
		;out.write(dsec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len csec) [i++]
		;out.write(csec{i})
	;/

	;out.write('\n')
	;out.close()
;/

