/##
	Copyright 2021-2022 Kyle Gunger

	This file is licensed under the CDDL 1.0 (the License)
	and may only be used in accordance with the License.
	You should have received a copy of the License with this
	software/source code. If you did not, a copy can be found
	at the following URL:

	https://opensource.org/licenses/CDDL-1.0

	THIS SOFTWARE/SOURCE CODE IS PROVIDED "AS IS" WITH NO
	WARRANTY, GUARANTEE, OR CLAIM OF FITNESS FOR ANY PURPOSE
	EXPRESS OR IMPLIED
#/


;{}{}charp COMMON_ASM = {
	"\tret\n"
}

# Represents a type
;struct VType {
	uint
		_size,
	int
		ptr,
	
	{}charp name,

	{}{}charp sub_types
}

/; method VType
	/; get_sub_type({}charp name) [VType]
		/; loop (int i = 0; i < len (self.sub_types)) [i = i + 2]
			/; if (string_equate(~name, ~(self.sub_types{i + 1})))
				;return vtype_by_name(self.sub_types{i})
			;/
		;/
		;return NT
	;/

	/; get_offset({}charp name) [int]
		;int out = 0
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (string_equate(~name, ~(self.sub_types{i*2 + 1})))
				;return out
			;; else if (self.on_stack{i})
				;VType tmp = vtype_by_name(self.sub_types{i*2})
				;out = out + tmp.size
			;/
		;/
		;return -1
	;/
;/

# Tracks defined variables in a block
;struct VTrack {
	{}{}charp
		sym_names,
	
	{}bool
		on_stack,

	{}VType
		sym_types
}

/; method VTrack
	# returns true if the value is allocated to the stack
	/; add_track({}charp name, VType _type) [int]
		;bool to_stack = is_struct(_type)
		;int count = 0

		/; loop (int i = 0; i < len (self.on_stack) && !to_stack) [i++]
			/; if (!self.on_stack{i})
				;count++
			;/

			/; if (count > 7)
				;to_stack = true
			;/
		;/

		;self.sym_names.append(name)
		;self.sym_types.append(_type)
		;self.on_stack.append(to_stack)

		/; if (count > 7)
			;return -1
		;/

		;return count
	;/

	# Returns true if the variable is being tracked
	/; in_vtrack({}charp name) [bool]
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (string_equate(~name, ~(self.sym_names{i})))
				;return true
			;/
		;/
		;return false
	;/

	# Returns the total allocated memory on the stack for this tracker
	/; stack_total [int]
		;int out = 0
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (self.on_stack{i})
				;out = out + (self.sym_types{i}._size)
			;/
		;/
		;return out
	;/

	# returns the type of the named variable
	/; get_vtype ({}charp name) [VType]
		/; loop (int i = 0; i < len (self.on_stack)) [i++]
			/; if (string_equate(~name, ~(self.sym_names{i})))
				;return (self.sym_types{i})
			;/
		;/
	;/
;/

# Sizes of items
;{}VType type_table = {
	{1, 0, "int8", {}},
	{2, 0, "int16", {}},
	{4, 0, "int32", {}},
	{8, 0, "int64", {}},
	{8, 0, "int", {}},
	{1, 0, "uint8", {}},
	{2, 0, "uint16", {}},
	{4, 0, "uint32", {}},
	{8, 0, "uint64", {}},
	{8, 0, "uint", {}},
	{4, 0, "float32", {}},
	{8, 0, "float64", {}},
	{8, 0, "float", {}},
	{1, 0, "bool", {}},
	{8, 0, "void", {}}
}

# Null type
;VType NT = {0, 0, "null", {}}

# Returns an index in the vtrack for a given variable name
/; name_to_index ({}charp name, ~VTrack tab) [int]
	/; loop (int i = 0; i < len (tab`.sym_names)) [i++]
		/; if (string_equate(tab`.sym_names{i}, name))
			;return i
		;/
	;/

	;tnsl.io.print("Failed to find vairable ")
	;tnsl.io.println(name)

	;return -1
;/

# The commonly used registers in order
/; reg_by_num(int r) [{}charp]
	/; if (r == 0)
		;return "ax"
	;; if (r == 1)
		;return "bx"
	;; if (r == 2)
		;return "cx"
	;; if (r == 3)
		;return "dx"
	;; if (r == 4)
		;return "si"
	;; if (r == 5)
		;return "di"
	;; if (r == 6)
		;return "bp"
	;; if (r == 7)
	;/
	;return string_from_int(r)
;/

# Given an index in the vtrack, returns a string representation of the
# register or memory where that variable is
/; index_to_loc (int index, ~VTrack tab) [{}charp]
	;{}charp out = ""
	;int stack_bytes = 0
	;int reg = 0
	;int i = 0

	/; loop (i < index) [i++]
		/; if (tab`.sym_types{i}._size !> 8 && reg < 7)
			;reg++
		;; else
			;stack_bytes = stack_bytes + tab`.sym_types{i}._size
		;/
	;/

	/; if (is_struct(tab`.sym_types{index}))
		;out = "(todo: structs)"
	;; else
		;out = reg_by_num(reg)
	;/
	
	;return out
;/

# Is struct returns true if the type name given is a struct
/; is_struct (VType t) [bool]
	/; if (t.ptr > 0)
		;return false
	;/

	/; loop (int i = 0; i < 15) [i++]
		/; if (string_equate(type_table{i}.name, t.name))
			;return false
		;/
	;/

	;return true
;/

# Using the type name and member name, create a label of form "_type.member"
/; construct_offset_label ({}charp t, {}charp n) [{}charp]
	;{}charp out = "_"
	;add_strings(~out, ~t)
	;out.append('.')
	;add_strings(~out, ~n)
	;return out
;/

# Using the given offset (in bytes), return an asm value of form ".quad <offset>"
/; construct_value (int size, int offset) [{}charp]
	;{}charp out = ".byte "
	/; if (size == 2)
		;out = ".word "
	;; if (size == 4)
		;out = ".long"
	;; if (size == 8)
		;out = ".quad "
	;/
	;{}charp tmp = string_from_int(offset)
	;add_strings(~out, ~tmp)
	;return out
;/

/; construct_text_value ({}charp t) [{}charp]
	;{}charp tmp = unquote_string(t)
	;{}charp out = construct_value(1, len tmp)
	;{}charp tmp = "\n\t.ascii "
	;add_strings(~out, ~tmp)
	;add_strings(~out, ~t)
	;return out
;/

/; construct_mov_literal({}charp value, reg) [{}charp]
	;{}charp tmp = "$"
	;add_strings(~tmp, ~value)
	;return mov_asm(tmp, reg)
;/

# Parse a struct and add it to the table
/; def_struct (~int cur, ~{}Token data, ~{}charp dsec) [VType]
	;VType out = {0, 0, "", {}}
	;cur`++

	;out.name = data`{cur`}.data`

	;cur`++
	;cur`++
	# Should be indexed at first type in the type list

	/; if (token_is(cur, data, "}"))
		;return NT
	;/

	;VType ctype = get_vtype(cur, data)
	;cur`++

	/; loop (cur` < len data`) [cur`++]
		/; if (token_is(cur, data, "}"))
			;break
		;; else if (token_is(cur, data, ","))
			;cur`++
		;/

		;cur`++
		/; if (token_is(cur, data, ",") || token_is(cur, data, "}"))
			# Use ctype
			;cur`--
			;{}charp l = construct_offset_label(out.name, data`{cur`}.data`)
			;l.append(':')
			;l.append(' ')
			;{}charp p = construct_value(8, out._size)

			/; if (ctype.ptr > 0)
				;p = construct_value(8, 8)
				;out._size = out._size + 8
			;; else
				;out._size = out._size + ctype._size
			;/

			;out.sub_types.append(ctype.name)
			;out.sub_types.append(data`{cur`}.data`)

			;p.append('\n')
			;add_strings(~l, ~p)
			# add "_type.member: .qword #offset_value" to data section
			
			;add_strings(dsec, ~l)
			
		;; else
			# Get type
			;cur`--
			;ctype = get_vtype(cur, data)
		;/
	;/

	;type_table.append(out)
	;return out
;/

# Checks if the current token's data member is equal to a given string
/; token_is(~int cur, ~{}Token data, {}charp str) [bool]
	;return string_equate(data`{cur`}.data`, str)
;/

# Skips in a definition or list until it finds a name
/; skip_to_name (~int cur, ~{}Token data)
	;int tmp = 0
	/; loop (cur` < len data`) [cur`++]
		;tmp = cur` + 1
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && 
				( token_is(~tmp, data, ",") || token_is(~tmp, data, ")") || token_is(~tmp, data, "}") || token_is(~tmp, data, ";") ))
			;break
		;/
	;/
;/

# Searches the type table for a type
/; vtype_by_name ({}charp name) [VType]
	/; loop (int i = 0; i < len type_table) [i++]
		;VType tmp = tnslc.type_table{i}
		/; if (string_equate(name, tmp.name))
			;return tmp
		;/
	;/
	;return NT
;/

# Parses a type in a definition or list
/; get_vtype (~int cur, ~{}Token data) [VType]
	;uint ptr = 0
	;VType out = NT

	/; loop (cur` < len data`) [cur`++]
		;int i = data`{cur`}.token_type
		/; if (token_is(cur, data, "~") || token_is(cur, data, "{"))
			;ptr++
		;; else if (i == TOKEN_TYPE.DEFWORD || i == TOKEN_TYPE.KEYTYPE)
			;out = vtype_by_name(data`{cur`}.data`)
			;break
		;; else if (!token_is(cur, data, "}"))
			;break
		;/
	;/

	;out.ptr = ptr

	;return out
;/

# Assumes cur points to the beginning of the arguments list
# Sets up the VTrack struct that is pointed to.
/; setup_vtrack (~int cur, ~{}Token data, ~VTrack tab)
	;cur`++

	;VType last = NT

	/; loop (cur` < len data`) [cur`++]
		;int pre_skip = cur`
		/; if (token_is(cur, data, ")"))
			;break
		;; else if (!token_is(cur, data, ","))
			;skip_to_name(cur, data)
			/; if (pre_skip == cur`)
				;tab`.sym_types.append(last)
				;tab`.sym_names.append(data`{cur`}.data`)
			;; else
				;last = get_vtype(~pre_skip, data)
				;tab`.sym_types.append(last)
				;tab`.sym_names.append(data`{cur`}.data`)
			;/
		;/
	;/
;/

# Mostly deals with structs and enums
/; compile_global (~int cur, ~{}Token data, ~VTrack gsc, ~{}charp hsec, csec, dsec)
	;cur`++
	/; if (token_is(cur, data, "struct"))
		;def_struct(cur, data, dsec)
	;/
;/

# Evaluate a value and return it to the register pointed at by reg
/; eval_value (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}charp hsec, csec, dsec, int reg)
	/; if (token_is(cur, data, ";/"))
		;return
	;/

	;int val_layer = 0

	/; loop (cur` < len data`)
		/; if (data`{cur`}.token_type == TOKEN_TYPE.LITERAL)
			/; if (data`{cur`}.data`{0} == '"')
				# String literal
			
			;; else if (data`{cur`}.data`{0} == '\'')
				# Char literal
			;; else
				# int literal
				;{}charp tmp = construct_mov_literal(data`{cur`}.data`, get_reg(8, reg_by_num(val_layer)))
				;add_strings(csec, ~tmp)
				;val_layer++
				;cur`++
			;/
		;; else if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD)
		;; else if (token_is(cur, data, "~"))
		;; else if (data`{cur`}.token_type == TOKEN_TYPE.AUGMENT)
		;; else
			;break
		;/
	;/
;/

# Sets up a call and reports back where the return value is stored
/; eval_call (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}charp hsec, csec, dsec) [{}charp]
	
		# Store the name of the function we are calling
	;{}charp to_call = data`{cur`}.data`

		# Set read head to first parameter
	;cur` = cur` + 2
	;int reg = 0
	/; loop (!token_is(cur, data, ")"))
		/; if (token_is(cur, data, ","))
			;cur`++
		;; else
			/; if (reg < 7)
				;eval_value(cur, data, tab, gsc, hsec, csec, dsec, reg)
				;reg++
			;; else
				;eval_value(cur, data, tab, gsc, hsec, csec, dsec, reg)
				;push_asm(get_reg(8, "bp"))
			;/
		;/
	;/

	;{}charp call_ist = call_asm(to_call)

	;add_strings(csec, ~call_ist)
	;return "ax"
;/

/; set_struct_value (~{}charp csec)

;/

/; copy_struct ({}charp from, to, VType t) [{}charp]
	;{}charp out = ""
	;{}charp init = ""
;/

/; set_value ({}charp from, to, int size, ~{}charp csec)
	/; if (is_common_reg(from))
		;from = get_reg(size, from)
	;; if (is_common_reg(to))
		;to = get_reg(size, to)
	;/

	;{}charp tmp = "\tmov"
	/; if (size == 1)
		;mov.append('b')
	;; else if (size == 2)
		;mov.append('d')
	;; else if (size == 4)
		;mov.append('w')
	;; else if (size == 8)
		;mov.append('q')
	;/

	;tmp = construct_statement(tmp, {from, to})
	;add_strings(csec, ~tmp)
;/

# Compile a statement in a function
/; compile_statement (~int cur, ~{}Token data, ~VTrack tab, gsc, ~{}charp hsec, csec, dsec) [bool]
	;cur`++
	;bool r = false
	/; if (cur` < len data`)
		/; if (token_is(cur, data, "asm"))
			;cur`++
			;{}charp raw_asm = unquote_string(data`{cur`}.data`)
			;raw_asm.append('\n')
			;csec`.append('\t')
			;add_strings(csec, ~raw_asm)
			;cur`++
		;; else if (token_is(cur, data, "raw"))
			;cur`++
			;r = true
		;; else if (token_is(cur, data, "return"))
			;cur`++
			;eval_value(cur, data, tab, gsc, hsec, csec, dsec, 0)
			;tail_guard(csec)
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;return true
		;; else if (string_equate(data`{cur`+1}.data`, "("))
			# Function call
			;eval_call(cur, data, tab, gsc, hsec, csec, dsec)
		;; else if (name_to_index(data`{cur`}.data`, tab) !< 0)
			# set value
			;int i = name_to_index(data`{cur`}.data`, tab)
			;{}charp tmp = index_to_loc(i)
			;eval_value(cur, data, tab, gsc, hsec, csec, dsec, 0)
			;tmp = mov_asm(get_reg(tab`.sym_types{i}._size, "ax"), tmp)
			;add_strings(csec, ~tmp)
		;; else
			#Definition
			;VType def_t = get_vtype(cur, data)
			;cur`++
			
			/; loop (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD)
				;int stack = tab`.add_track()
				
				/; if (token_is(cur, data, ","))
					;cur`++
				;; else if (token_is(cur, data, "="))
					;{}charp loc = index_to_loc(len tab`.sym_names - 1, tab)
					;eval_value(cur, data, tab, gsc, hsec, csec, dsec, loc)
					/; if (token_is(cur, data, ","))
						;cur`++
					;/
				;/
			;/
			/; if (string_equate(data`{cur`+1}.data`, "="))

			;/
		;; if (token_is(cur, data, "return"))
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;return true
		;/
	;/

	;return false
;/



/; compile_block (~int cur, ~{}Token data, ~VTrack gsc, ~{}charp hsec, csec, dsec)
	;VTrack tab = { {}, {}, {} }
	;VType out_type = NT
	;{}charp name = ""
	;bool r = false

	/; loop (cur`++; cur` < len data`) [cur`++]
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && len name == 0)
			;name = data`{cur`}.data`
			;add_strings(csec, ~name)
			;csec`.append(':')
			;csec`.append('\n')
		;; else if (token_is(cur, data, "("))
			;setup_vtrack(cur, data, ~tab)
		;; else if (token_is(cur, data, "["))
			;cur`++
			;out_type = get_vtype(cur, data)
			;cur`++
		;; else if (token_is(cur, data, "raw"))
			;r = true
		;; else
			;break
		;/
	;/

	;tnsl.io.println(out_type.name)

	/; if (!r)
		;header_guard(csec)
	;/

	;bool ret = false
	/; loop (cur` < len data` && !ret)
		/; if (string_equate(data`{cur`}.data`, ";/"))
			/; if (!r)
				;tail_guard(csec)
			;/
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;break
		;; else if (string_equate(data`{cur`}.data`, "/;"))
			;bool ch = true
			/; loop (ch)
				;compile_block(cur, data, gsc, hsec, csec, dsec)
				/; if (cur` !< len data`)
					;break
				;/
				;ch = string_equate(data`{cur`}.data`, ";;")
			;/			
		;; else if (string_equate(data`{cur`}.data`, ";"))
			;ret = compile_statement(cur, data, ~tab, gsc, hsec, csec, dsec)
		;; else
			;tnsl.io.print("Failed to compile token [compile_block]: ")
			;data`{cur`}.print()
			;tnsl.io.println("")
			;break
		;/
	;/

	;csec`.append('\n')
;/

/; compile_include (Path file_path, ~VTrack global, ~{}charp hsec, csec, dsec)
	# Autocomplete in the case of module syntax
	;bool d = file_path.extension_is("tnsl")
	/; if (!d)
		;file_path.dirs.append(file_path.file)
		;{}charp ftmp = file_path.file
		;{}charp tmp = ".tnsl"
		;add_strings(~ftmp, ~tmp)
		;file_path.file = ftmp
	;/

	;tnsl.io.print("[TNSLC:INCLUDE] ")
	;tnsl.io.println(file_path.full_path())

	;tnsl.io.File inc = file_path.open_r()
	;~{}Token data = parse.tokenize(inc)
	;inc.close()

	;tnsl.io.print(len data`)
	;tnsl.io.println(" tokens parsed.")
	
	;compile_file(file_path, data, global, hsec, csec, dsec)
;/

/; compile_file (Path rel, ~{}Token data, ~VTrack global, ~{}charp hsec, csec, dsec)
	
	;int j = len data`

	/; loop (int i = 0; i < j) [i++]
		/; if (string_equate(data`{i}.data`, "/;"))
			;compile_block(~i, data, global, hsec, csec, dsec)
		;; else if (string_equate(data`{i}.data`, ";"))
			;compile_global(~i, data, global, hsec, csec, dsec)
		;; else if (string_equate(data`{i}.data`, ":"))
			;i = i + 2
			;Path inc = rel.rel_file(unquote_string(data`{i}.data`))
			;compile_include(inc, global, hsec, csec, dsec)
		;; else
			;break
		;/
	;/

;/

/; do_compile ({}charp file_out, Path rel)
	;{}charp hsec = ".global main\n"
	;{}charp csec = ".text\n"
	;{}charp dsec = ".data\n"
	
	;VTrack global_scope = {{}, {}}

	;tnslc.compile_include(rel, ~global_scope, ~hsec, ~csec, ~dsec)

	;tnsl.io.File out = tnsl.io.writeFile(file_out)
	
	/; loop (int i = 0; i < len hsec) [i++]
		;out.write(hsec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len csec) [i++]
		;out.write(csec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len dsec) [i++]
		;out.write(dsec{i})
	;/

	;out.write('\n')
	;out.close()
;/

