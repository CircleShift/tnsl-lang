/##
	Copyright 2021-2022 Kyle Gunger

	This file is licensed under the CDDL 1.0 (the License)
	and may only be used in accordance with the License.
	You should have received a copy of the License with this
	software/source code. If you did not, a copy can be found
	at the following URL:

	https://opensource.org/licenses/CDDL-1.0

	THIS SOFTWARE/SOURCE CODE IS PROVIDED "AS IS" WITH NO
	WARRANTY, GUARANTEE, OR CLAIM OF FITNESS FOR ANY PURPOSE
	EXPRESS OR IMPLIED
#/


;{}{}charp COMMON_ASM = {
	"\tret",
	"\tpush %",
	"\tpop %"
}

;struct VType {
	uint
		_size,
	int
		ptr,
	
	{}charp name
}

;struct VTrack {
	{}{}charp
		sym_names,
	
	{}VType
		sym_types
}

# Sizes of items
;{}VType type_table = {
	{1, 0, "int8"},
	{2, 0, "int16"},
	{4, 0, "int32"},
	{8, 0, "int64"},
	{8, 0, "int"},
	{1, 0, "uint8"},
	{2, 0, "uint16"},
	{4, 0, "uint32"},
	{8, 0, "uint64"},
	{8, 0, "uint"},
	{4, 0, "float32"},
	{8, 0, "float64"},
	{8, 0, "float"},
	{1, 0, "bool"},
	{8, 0, "void"}
}

# Null type
;VType NT = {0, 0, "null"}

/; name_to_index ({}charp name, ~VTrack tab) [int]
	/; loop (int i = 0; i < len tab`.sym_names) [i++]
		/; if (string_equate(tab`.sym_names{i}, name))
			;return i
		;/
	;/

	;tnsl.io.print("Failed to find vairable ")
	;tnsl.io.println(name)

	;return -1
;/

/; index_to_loc (int index, ~VTrack tab) [{}charp]
	;{}charp out = ""
	;int stack_bytes = 0
	;int reg = 0
	;int i = 0

	/; loop (i < index) [i++]
		/; if (tab`.sym_types{i}._size !> 8 && reg < 7)
			;reg++
		;; else
			;stack_bytes = stack_bytes + tab`.sym_types{i}._size
		;/
	;/
	
	;return out
;/

/; token_is(~int cur, ~{}Token data, {}charp str) [bool]
	;return string_equate(data`{cur`}.data`, str)
;/

/; skip_to_name (~int cur, ~{}Token data)
	;int tmp = 0
	/; loop (cur` < len data`) [cur`++]
		;tmp = cur` + 1
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && ( token_is(~tmp, data, ",") || token_is(~tmp, data, ")") ))
			;break
		;/
	;/
;/

/; vtype_by_name ({}charp name) [VType]
	/; loop (int i = 0; i < len type_table) [i++]
		;VType tmp = tnslc.type_table{i}
		/; if (string_equate(name, tmp.name))
			;return tmp
		;/
	;/
	;return NT
;/

/; get_vtype (~int cur, ~{}Token data) [VType]
	;uint ptr = 0
	;VType out = NT

	/; loop (cur` < len data`) [cur`++]
		;int i = data`{cur`}.token_type
		/; if (token_is(cur, data, "~") || token_is(cur, data, "{"))
			;ptr++
		;; else if (i == TOKEN_TYPE.DEFWORD || i == TOKEN_TYPE.KEYTYPE)
			;out = vtype_by_name(data`{cur`}.data`)
			;break
		;; else if (!token_is(cur, data, "}"))
			;break
		;/
	;/

	;out.ptr = ptr

	;return out
;/

/; setup_vtrack (~int cur, ~{}Token data, ~VTrack tab)
	;cur`++

	;VType last = NT

	/; loop (cur` < len data`) [cur`++]
		;int pre_skip = cur`
		/; if (token_is(cur, data, ")"))
			;break
		;; else if (!token_is(cur, data, ","))
			;skip_to_name(cur, data)
			/; if (pre_skip == cur`)
				;tab`.sym_types.append(last)
				;tab`.sym_names.append(data`{cur`}.data`)
			;; else
				;cur` = pre_skip
				;last = get_vtype(cur, data)
				;skip_to_name(cur, data)
				;tab`.sym_types.append(last)
				;tab`.sym_names.append(data`{cur`}.data`)
			;/
		;/
	;/
;/

/; compile_statement (~int cur, ~{}Token data, ~{}charp hsec, csec, dsec)
	;cur`++
	/; if (cur` < len data`)
		/; if (token_is(cur, data, "asm"))
			;cur`++
			;{}charp raw_asm = unquote_string(data`{cur`}.data`)
			;raw_asm.append('\n')
			;csec`.append('\t')
			;add_strings(csec, ~raw_asm)
		;/
	;/
;/

/; compile_block (~int cur, ~{}Token data, ~{}charp hsec, csec, dsec)
	;VTrack tab = { {}, {} }

	;{}charp name = ""
	;bool r = false
	/; loop (cur`++; cur` < len data`) [cur`++]
		/; if (data`{cur`}.token_type == TOKEN_TYPE.DEFWORD && len name == 0)
			;name = data`{cur`}.data`
			;add_strings(csec, ~name)
			;csec`.append(':')
			;csec`.append('\n')
		;; else if (token_is(cur, data, "("))
			;setup_vtrack(cur, data, ~tab)
		;; else if (token_is(cur, data, "["))
			/; loop (cur`++; cur` < len data`) [cur`++]
				/; if (token_is(cur, data, "]"))
					;break
				;/
			;/
		;; else if (token_is(cur, data, "raw"))
			;r = true
		;; else
			;break
		;/
	;/

	/; if (!r)
		;header_guard(tab, csec)
	;/

	/; loop (cur` < len data`) [cur`++]
		/; if (string_equate(data`{cur`}.data`, ";/"))
			;add_strings(csec, ~(tnslc.COMMON_ASM{0}))
			;break
		;; else if (string_equate(data`{cur`}.data`, "/;"))
			;bool ch = true
			/; loop (ch)
				;compile_block(cur, data, hsec, csec, dsec)
				/; if (cur` !< len data`)
					;break
				;/
				;ch = string_equate(data`{cur`}.data`, ";;")
			;/			
		;; else if (string_equate(data`{cur`}.data`, ";"))
			;compile_statement(cur, data, hsec, csec, dsec)
		;; else
			;tnsl.io.print("Failed to compile token [compile_block]: ")
			;data`{cur`}.print()
			;tnsl.io.println("")
			;break
		;/
	;/

	/; if (!r)
		;tail_guard(csec)
	;/

	;csec`.append('\n')
;/

/; do_compile ({}charp file, ~{}Token data)
	;{}charp hsec = ".global main\n"
	;{}charp csec = ".text\n"
	;{}charp dsec = ".data\n"

	;int j = len data`
	
	/; loop (int i = 0; i < j) [i++]
		/; if (string_equate(data`{i}.data`, "/;"))
			;compile_block(~i, data, ~hsec, ~csec, ~dsec)
		;; else if (string_equate(data`{i}.data`, ";"))
			;compile_statement(~i, data, ~hsec, ~csec, ~dsec)
		;; else
			;break
		;/
	;/
	
	;{}charp tmp = mem_offset("%edi", "%edx", "1")
	;add_strings(~csec, ~tmp)

	;tnsl.io.File out = tnsl.io.writeFile(file)
	
	/; loop (int i = 0; i < len hsec) [i++]
		;out.write(hsec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len csec) [i++]
		;out.write(csec{i})
	;/

	;out.write('\n')

	/; loop (int i = 0; i < len dsec) [i++]
		;out.write(dsec{i})
	;/

	;out.write('\n')
	;out.close()
;/

