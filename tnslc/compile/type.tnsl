struct Variable {
	~uint8 name,
	~Type _type,
	utils.Vector ptr
}

/; method Variable
	/; init (~uint8 name)
		self.name = name
		self.ptr.init(8)
	;/

	/; add_ptr(uint ptp)
		self.ptr.push(~ptp)
	;/

	/; get_ptr [uint]
		/; if (self.ptr.count == 0)
			return 0
		;/
		~uint p = self.ptr.get(self.ptr.count - 1)
		return p`
	;/

	/; pop_ptr [uint]
		/; if (self.ptr.count == 0)
			return 0
		;/
		~uint p = self.ptr.get(self.ptr.count - 1)
		uint out = p`
		self.ptr.pop()
		return out
	;/

	/; end
		_delete(self.name)
		self.ptr.end()
	;/
;/

struct Type {
	~uint8 name,
	uint size,
	utils.Vector vars,
	~Module methods,
}

/; method Type
	/; init(~uint8 name)
		self.name = name
		Variable tmp
		self.vars.init(len tmp)
	;/

	/; add_var (~Variable v)
		self.vars.push(v)
	;/

	/; end
		_delete(self.name)
		/; loop (int i = 0; i < self.vars.count) [i++]
			~Variable v = self.vars.get(i)
			v`.end()
		;/
		self.vars.end()
	;/
;/

struct Function {
	~uint8
		name,
	~parse.Node
		body,
	utils.Vector
		inputs,
		outputs
}

/; method Function
	/; init (~uint8 name)
		self.name = name
		Variable vtmp
		~uint i
		self.inputs.init(len vtmp)
		self.outputs.init(len i)
	;/

	/; add_input (~Variable v)
		self.inputs.push(v)
	;/

	/; add_output (~Type t)
		self.outputs.push(~t)
	;/

	/; end
		_delete(self.name)

		/; loop (int i = 0; i < self.inputs.count) [i++]
			~Variable v = self.inputs.get(i)
			v`.end()
		;/
		self.inputs.end()

		self.outputs.end()
	;/
;/

struct Enum {
	~uint8 name,
	~Type _type,
	utils.Vector vals
}

/; method Enum
	/; init (~uint8 name)
		self.name = name
		Variable vtmp
		self.vals.init(len vtmp)
	;/

	/; end
		_delete(self.name)
		/; loop (int i = 0; i < self.vals.count) [i++]
			~Variable v = self.vals.get(i)
			v`.end()
		;/
		self.vals.end()
	;/
;/

struct Module {
	~uint8 name,
	~Module parent,
	bool exp,
	utils.Vector
		sub,
		vars,
		types,
		funcs,
		enums

}

uint8 MOD_FIND_SUB = 0
uint8 MOD_FIND_VAR = 1
uint8 MOD_FIND_TYP = 2
uint8 MOD_FIND_FUN = 3
uint8 MOD_FIND_ENM = 4

/; method Module
	/; init (~uint8 name)
		self.name = name
		Module mtmp
		Variable vtmp
		Type ttmp
		Function ftmp
		Enum etmp
		self.sub.init(len mtmp)
		self.vars.init(len vtmp)
		self.types.init(len ttmp)
		self.funcs.init(len ftmp)
		self.enums.init(len etmp)
	;/

	/; update_children
		/; loop (int i = 0; i < self.sub.count) [i++]
			~Module s = self.sub.get(i)
			s`.parent = ~self
		;/
	;/

	/; add_sub(~Module m) [~Module]
		self.sub.push(m)
		/; loop (int i = 0; i < self.sub.count) [i++]
			~Module s = self.sub.get(i)
			s`.update_children()
		;/
		return self.sub.get(self.sub.count - 1)
	;/

	/; add_var (~Variable v)
		self.vars.push(v)
	;/

	/; add_type (~Type t)
		self.types.push(t)
	;/

	/; add_funcs (~Function f)
		self.funcs.push(f)
	;/

	/; add_enum (~Enum e)
		self.enums.push(e)
	;/

	/; _find_rec (utils.Artifact pth, uint8 typ, int sub) [~void]
		/; if (sub !< pth.count)
			return NULL
		;; else if ((sub + 1) < pth.count)
			/; loop (int i = 0; i < self.sub.count) [i++]
				~Module m = self.sub.get(i)
				/; if (utils.strcmp(pth.get(sub), m`.name) == true)
					return _find_rec(pth, typ, sub + 1)
				;/
			;/
		;; else
			/; if (typ == MOD_FIND_SUB)
				/; loop (int i = 0; i < self.sub.count) [i++]
					~Module m = self.sub.get(i)
					/; if (utils.strcmp(pth.get(sub), m`.name) == true)
						return self.sub.get(i)
					;/
				;/
			;; else if (typ == MOD_FIND_VAR)
				/; loop (int i = 0; i < self.vars.count) [i++]
					~Variable v = self.vars.get(i)
					/; if (utils.strcmp(pth.get(sub), v`.name) == true)
						return self.vars.get(i)
					;/
				;/
			;; else if (typ == MOD_FIND_TYP)
				/; loop (int i = 0; i < self.types.count) [i++]
					~Type t = self.types.get(i)
					/; if (utils.strcmp(pth.get(sub), t`.name) == true)
						return self.types.get(i)
					;/
				;/
			;; else if (typ == MOD_FIND_FUN)
				/; loop (int i = 0; i < self.funcs.count) [i++]
					~Function f = self.funcs.get(i)
					/; if (utils.strcmp(pth.get(sub), f`.name) == true)
						return self.funcs.get(i)
					;/
				;/
			;; else if (typ == MOD_FIND_ENM)
				/; loop (int i = 0; i < self.enums.count) [i++]
					~Enum e = self.enums.get(i)
					/; if (utils.strcmp(pth.get(sub), e`.name) == true)
						return self.enums.get(i)
					;/
				;/
			;/
		;/
		
		/; if (self.parent == NULL || sub !== 0)
			return NULL
		;/

		return self.parent._find_rec(pth, typ, 0)
	;/

	/; find (utils.Artifact pth, uint8 typ) [~void]
		return _find_rec(pth, typ, 0)
	;/

	/; end
		_delete(self.name)

		/; loop (int i = 0; i < self.sub.count) [i++]
			~Module m = self.sub.get(i)
			m`.end()
		;/
		self.sub.end()

		/; loop (int i = 0; i < self.vars.count) [i++]
			~Variable v = self.vars.get(i)
			v`.end()
		;/
		self.vars.end()

		/; loop (int i = 0; i < self.types.count) [i++]
			~Type t = self.types.get(i)
			t`.end()
		;/
		self.types.end()

		/; loop (int i = 0; i < self.funcs.count) [i++]
			~Function f = self.funcs.get(i)
			f`.end()
		;/
		self.funcs.end()

		/; loop (int i = 0; i < self.enums.count) [i++]
			~Enum e = self.enums.get(i)
			e`.end()
		;/
		self.enums.end()
	;/
;/

{}~uint8 GEN_VAR_NAMES = { "int\0", "int8\0", "int16\0", "int32\0", "int64\0", "uint\0", "uint8\0", "uint16\0", "uint32\0", "uint64\0", "float\0", "float32\0", "float64\0", "vect\0", "bool\0", "void\0" }

{}uint GEN_VAR_SIZES = { 8, 1, 2, 4, 8, 8, 1, 2, 4, 8, 8, 4, 8, 0, 1, 8}

/; find_type(utils.Artifact a, ~parse.Node n) [~parse.Node]
	return NULL
;/

/; transform_struct(~parse.Node n, ~Module parent)
;/

/; _tfn_mod_loop (~parse.Node n, ~Module m)
	/; loop (int i = 0; i < n`.sub.count) [i++]
		~parse.Node s = n`.sub.get(i)
		/; if (s`._type == parse.NTYPE_MODULE || s`._type == parse.NTYPE_EXPORT)
			transform_module(s, m)
		;; else if (s`._type == parse.NTYPE_STRUCT)
			transform_struct(s, m)
		;/
	;/
;/

/; transform_module (~parse.Node n, ~Module parent)
	~Module s = NULL

	/; loop (int i = 0; i < parent`.sub.count) [i++]
		~Module tmp = parent`.sub.get(i)
		/; if (utils.strcmp(n`.data, tmp`.name) == true)
			s = tmp
		;/
	;/
	
	~int cmp = s
	/; if (cmp == NULL)
		Module out
		out.init(utils.strcpy(n`.data))

		/; if (n`._type == parse.NTYPE_EXPORT)
			out.exp = true
		;; else
			out.exp = false
		;/

		s = parent`.add_sub(~out)
	;/

	_tfn_mod_loop(n, s)
;/

/; _tfn_gen_default_types (~Module m)
	/; loop (int i = 0; i < len GEN_VAR_NAMES) [i++]
		Type t
		t.init(utils.strcpy(GEN_VAR_NAMES{i}))
		t.size = GEN_VAR_SIZES{i}
		m`.add_type(~t)
	;/
;/

/; transform_tree (~parse.Node n) [Module]
	Module out
	out.init(utils.strcpy(n`.data))
	out.exp = true

	_tfn_gen_default_types(~out)
	_tfn_mod_loop(n, ~out)

	return out
;/
