/##
	Copyright 2021-2022 Kyle Gunger

	This file is licensed under the CDDL 1.0 (the License)
	and may only be used in accordance with the License.
	You should have received a copy of the License with this
	software/source code. If you did not, a copy can be found
	at the following URL:

	https://opensource.org/licenses/CDDL-1.0

	THIS SOFTWARE/SOURCE CODE IS PROVIDED "AS IS" WITH NO
	WARRANTY, GUARANTEE, OR CLAIM OF FITNESS FOR ANY PURPOSE
	EXPRESS OR IMPLIED
#/

/# util.tnsl
    Utility functions that may be useful in many places.
#/

/; string_equate({}uint8 s1, s2) [bool]
    /; if (len s1 !== len s2)
        ;return false
    ;/

    /; loop (int i = 0; i < len s1) [i++]
        /; if (s1{i} !== s2{i})
            ;return false
        ;/
    ;/

    ;return true
;/

/; add_strings (~{}uint8 a, b)
    /; loop (int i = 0; i < len b`) [i++]
        ;a`.append(b`{i})
    ;/
;/

/; reverse_string({}uint8 str) [{}uint8]
	;{}uint8 out = ""

	/; loop (int i = len str; i > 0) [i = i - 1]
		;out.append(str{i - 1})
	;/

	;return out
;/

/; is_whitespace (uint8 c) [bool]
	;return c == '\t' || c == '\n' || c == ' '
;/

/; is_digit (uint8 c) [bool]
	;return c !< '0' && c !> '9'
;/

/; is_alpha (uint8 c) [bool]
    ;bool low = c !< 'A' && c !> 'Z', high = c !< 'a' && c >! 'z'
    ;return low || high
;/

/; digit_to_char(int i) [uint8]
    ;uint8 out = '0'
    ;out = out + (i % 10)
    ;return out
;/

/; string_from_int(int i) [{}uint8]
    ;{}uint8 c = ""

    /; if (i < 0)
        ;c = "-"
        ;i = -i
    ;/

    ;c.append(digit_to_char(i))
	;i = i / 10

    /; loop (i !== 0) [i = i / 10]
        ;c.append(digit_to_char(i))
    ;/

    ;return reverse_string(c)
;/

/; int_from_string ({}uint8 str) [int]
	;bool inv = str{0} == '-'
	;int out = 0

	/; loop ()

	;/
	
	/; if (inv)
		;out = -out
	;/

	;return out
;/

/; get_escape_code (uint8 c) [uint8]
    /; if (c == '\'')
        ;return '\''
    ;; else if (c == '"')
        ;return '"'
    ;; else if (c == 'a')
        ;return '\a'
    ;; else if (c == 'b')
        ;return '\b'
    ;; else if (c == 'e')
        ;return '\e'
    ;; else if (c == 'f')
        ;return '\f'
    ;; else if (c == 'n')
        ;return '\n'
    ;; else if (c == 'r')
        ;return '\r'
	;; else if (c == 't')
        ;return '\t'
	;; else if (c == 'v')
        ;return '\v'
	;/

    ;return 0
;/

/; parse_hex_code ({}uint8 c) [uint8]
    ;uint8 out = 0
	
    /; loop (int i = 0; i < len c) [i++]
        ;out = out * 16
        ;uint8 tmp = c{i}
        /; if (tmp !< 'a')
            ;tmp = tmp - 'a' + 'A'
        ;/

        /; if (tmp !< '0' && tmp !> '9')
            ;out = out + tmp - '0'
        ;; else if (tmp !< 'A' && tmp !> 'F')
            ;out = out + 10 + (tmp - 'A')
        ;; else
            ;break
        ;/
	;/

    ;return out
;/

/; unquote_char ({}uint8 c) [uint8]
    /; if (c{1} == '\\')
        /; if (c{2} == 'x')
            ;{}uint8 d = {c{3}, c{4}}
            ;return parse_hex_code(d)
        ;/
        ;return get_escape_code(c{2})
    ;/

    ;return c{1}
;/

/; unquote_string ({}uint8 str) [{}uint8]
    ;{}uint8 out = ""
    ;{}uint8 unc = "'"

    /; loop (int i = 1; i < len str - 1) [i++]
        /; if (str{i} == '\\')
            ;unc.append('\\')
            ;unc.append(str{i + 1})
            ;i++
            
            /; if (str{i} == 'x')
                ;unc.append(str{i + 1})
                ;unc.append(str{i + 2})
                ;i = i + 2
            ;/

            ;out.append(unquote_char(unc))
            ;unc = "'"
        ;; else
            ;out.append(str{i})
        ;/
    ;/

    ;return out
;/
